<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>

<!--
	Copyright (c) 1999-2008 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.meta - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="style.css">

<script>
function listanchors()
{
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        if (hash[text] > 0) continue;
        hash[text] = 1;
    values[n++] = a.name
    }

    values.sort();

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        newText += '<a href="#' + a + '"><span class="d_psymbol">'
                + a + '</span></a> ';
    }
    if (newText != "") newText = "<p><b>Jump to:</b> " + newText + '</p>';
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
</script>

</head>

<body onload="listanchors()">
<div id="content">
    <h1>std.meta</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std/internal/meta/meta.d -->
Generic templates and utilities for manipurating compile-time entities
themselves.  Compile-time entities include types, compile-time values,
symbols, and sequences of those entities.
<p></p>
All members in this module are defined in the implicit <span class="d_inlinecode"><a name="meta"></a><u>meta</u></span>
namespace and cannot be used without the <span class="d_inlinecode"><a name="meta"></a><u>meta</u></span> qualifier:
<pre class="d_code"><span class="d_keyword">import</span> std.<span class="d_psymbol">meta</span>;

<span class="d_comment">// Error! reverse is not defined. Use meta.reverse instead.
</span><span class="d_keyword">alias</span> reverse!(<span class="d_string">"x"</span>, 10, <span class="d_string">"y"</span>, 20) Rev;

<span class="d_comment">// Okay, qualified with meta.
</span><span class="d_keyword">alias</span> <span class="d_psymbol">meta</span>.reverse!(<span class="d_string">"x"</span>, 10, <span class="d_string">"y"</span>, 20) Rev;
</pre>

<p></p>
<b>Examples:</b><br><pre class="d_code">TODO
</pre>

<p></p>
<b>Source:</b><br>
<a href="http://github.com/sinfu/phobos-sandbox/blob/master/std/meta.d">std/meta.d</a> (which is just a shell around
             <a href="http://github.com/sinfu/phobos-sandbox/blob/master/std/internal/meta/meta.d">std/internal/meta/meta.d</a>)
<p></p>
<b>License:</b><br><a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>
<p></p>
<b>Authors:</b><br>Shin Fujishiro<p></p>

<dl><dt><div class="d_decl">template <a name="Id"></a><u>Id</u>(E)<br>template <a name="Id"></a><u>Id</u>(alias E)</div></dt>
<dd>Returns an alias to the passed compile-time entity <span class="d_inlinecode">E</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>E</td>
<td valign=top>A compile-time entity: type, compile-time value, or any symbol that
     has an identifier.</td></tr>
</table><p></p>
<b>Example:</b><br>
You may want to use <span class="d_inlinecode"><a name="Id"></a><u>Id</u></span> to alias a compile-time entity that
 may be a literal value.  The following example doesn't work without
 <span class="d_inlinecode"><a name="Id"></a><u>Id</u></span> since <span class="d_inlinecode">10</span> cannot be <span class="d_inlinecode">alias</span>ed.
<pre class="d_code"><span class="d_keyword">template</span> Front(seq...)
{
    <span class="d_keyword">alias</span> meta.<span class="d_psymbol">Id</span>!(seq[0]) Front;
}
<span class="d_keyword">alias</span> Front!(<span class="d_keyword">int</span>, <span class="d_keyword">short</span>) Type;  <span class="d_comment">// works
</span><span class="d_keyword">alias</span> Front!(10, 20, 30) value; <span class="d_comment">// works
</span></pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="Seq"></a><u>Seq</u>(seq...)</div></dt>
<dd>Returns an alias to a sequence of compile-time entities <span class="d_inlinecode">seq</span>. It's
the same thing as variadic template parameters.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>seq</td>
<td valign=top>Zero or more compile-time entities.</td></tr>
</table><p></p>
<b>Examples:</b><br>The following example makes a sequence of types <span class="d_inlinecode">Types</span> and uses its
 second element (= <span class="d_inlinecode">double</span>) to declare a variable <span class="d_inlinecode">value</span>.
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">Seq</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, string) Types;
Types[1] value = 3.14;
</pre>

 The sequence may contain compile-time expressions.  The following example
 makes a sequence of constant integers <span class="d_inlinecode">numbers</span> and embeds it into an
 array literal.
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">Seq</span>!(10, 20, 30) numbers;
<span class="d_keyword">int</span>[] arr = [ 0, numbers, 100 ];
<span class="d_keyword">assert</span>(arr == [ 0, 10, 20, 30, 100 ]);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">struct <a name="Packer"></a><u>Packer</u>(seq...);
<br>template <a name="pack"></a><u>pack</u>(seq...)</div></dt>
<dd><span class="d_inlinecode">meta.pack!(seq)</span> packs the sequence <span class="d_inlinecode">seq</span> into a single
compile-time entity.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>seq</td>
<td valign=top>Zero or more compile-time entities to pack.</td></tr>
</table><p></p>
<b>Returns:</b><br>A compile-time entity that packs <span class="d_inlinecode">seq</span> inside itself.
<p></p>

 The result can be <span class="d_inlinecode">alias</span>ed.  Sequences of packed entities can
 be iterated with the <span class="d_inlinecode">foreach</span> statement.
<pre class="d_code"><span class="d_comment">// Iterate through sequence of sequences of compile-time values.
</span><span class="d_keyword">alias</span> meta.pack!(1, 2, 3) A;
<span class="d_keyword">alias</span> meta.pack!(4, 5, 6) B;
<span class="d_keyword">alias</span> meta.pack!(7, 8, 9) C;

<span class="d_keyword">foreach</span> (i, pak; meta.Seq!(A, B, C))
{
    <span class="d_keyword">int</span>[] seq = [ pak.expand ];
}
</pre>

<p></p>
<span style="color:red">BUGS:</span><br>Too much instantiations of <span class="d_inlinecode">meta.pack</span> would hit <a href="http://d.puremagic.com/issues/show_bug.cgi?id=3372">Bugzilla 3372</a>
 and cause programs go mad on Windows.  The threshold depends on the
 program, but a few thousand instantiations might be dangerous.<p></p>

<dl><dt><div class="d_decl">alias <a name="expand"></a><u>expand</u>;
</div></dt>
<dd>Expands the packed sequence.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="length"></a><u>length</u>;
</div></dt>
<dd>The number of compile-time entities packed in.<p></p>

</dd>
<dt><div class="d_decl">alias <a name="Tag"></a><u>Tag</u>;
</div></dt>
<dd>Unique type associated with the packed sequence.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">template <a name="isPacked"></a><u>isPacked</u>(E)<br>template <a name="isPacked"></a><u>isPacked</u>(alias E)</div></dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if and only if <span class="d_inlinecode">E</span> is a packed sequence created
with the <span class="d_inlinecode">meta.pack</span>.
<p></p>
<b>Example:</b><br>
<span class="d_inlinecode">meta.zip</span> requires its arguments should be a sequence of packed
 sequences using <span class="d_inlinecode">meta.<a name="isPacked"></a><u>isPacked</u></span>.
<pre class="d_code"><span class="d_keyword">template</span> zip(seqs...)
    <span class="d_keyword">if</span> (meta.all!(meta.<span class="d_psymbol">isPacked</span>, seqs))
{
    <span class="d_comment">// ... implementation ...
</span>}
</pre>
<p></p>

</dd>
<dt><div class="d_decl">struct <a name="Tag"></a><u>Tag</u>(entities...);
</div></dt>
<dd><b>TODO:</b><br>
doc<p></p>

</dd>
<dt><div class="d_decl">template <a name="isSame"></a><u>isSame</u>(A,B)<br>template <a name="isSame"></a><u>isSame</u>(A,alias B) if (!isType!(B))<br>template <a name="isSame"></a><u>isSame</u>(alias A,B) if (!isType!(A))<br>template <a name="isSame"></a><u>isSame</u>(alias A,alias B) if (!isType!(A) &amp;&amp; !isType!(B))</div></dt>
<dd>Determines if <span class="d_inlinecode">A</span> and <span class="d_inlinecode">B</span> are the same compile-time entities
or not.  <span class="d_inlinecode">A</span> and <span class="d_inlinecode">B</span> are considered the same if their mangled
names as template arguments coincide with each other.
<p></p>
<b>Returns:</b><br><span class="d_inlinecode"><b>true</b></span> if and only if <span class="d_inlinecode">A</span> and <span class="d_inlinecode">B</span> are the same entity.

<p></p>
<b>Example:</b><br>
Comparing various entities.
<pre class="d_code"><span class="d_comment">// Compare types.
</span><span class="d_keyword">struct</span> MyType {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( meta.<span class="d_psymbol">isSame</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!meta.<span class="d_psymbol">isSame</span>!(MyType, <span class="d_keyword">double</span>));

<span class="d_comment">// Compare values.  Type is significant.
</span><span class="d_keyword">enum</span> str = <span class="d_string">"abc"</span>;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( meta.<span class="d_psymbol">isSame</span>!(str, <span class="d_string">"abc"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!meta.<span class="d_psymbol">isSame</span>!(10, 10u));      <span class="d_comment">// int and uint
</span>
<span class="d_comment">// Compare symbols.
</span><span class="d_keyword">void</span> fun() {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( meta.<span class="d_psymbol">isSame</span>!(fun, fun));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!meta.<span class="d_psymbol">isSame</span>!(fun, std));     <span class="d_comment">// function and package
</span></pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="isSame"></a><u>isSame</u>(A)<br>template <a name="isSame"></a><u>isSame</u>(alias A)</div></dt>
<dd>Convenience overloads.  If the second argument <span class="d_inlinecode">B</span> is omitted,
<span class="d_inlinecode">meta.<a name="isSame"></a><u>isSame</u>!A</span> binds <span class="d_inlinecode">A</span> to its own first parameter and returns a
partially applied template.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Bind double as A.
</span><span class="d_keyword">alias</span> meta.<span class="d_psymbol">isSame</span>!<span class="d_keyword">double</span> isDouble;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( isDouble!<span class="d_keyword">double</span>);    <span class="d_comment">// meta.isSame!(double, double)
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!isDouble!<span class="d_keyword">int</span>   );    <span class="d_comment">// meta.isSame!(double, int)
</span></pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="isType"></a><u>isType</u>(E)<br>template <a name="isType"></a><u>isType</u>(alias E)</div></dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if and only if a compile-time entity <span class="d_inlinecode">E</span> is a type.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">int</span>, <span class="d_string">"x"</span>,
             <span class="d_keyword">double</span>, <span class="d_string">"y"</span>,
             string, <span class="d_string">"z"</span>) mixed;

<span class="d_comment">// Filter out the types.
</span><span class="d_keyword">alias</span> meta.filter!(meta.<span class="d_psymbol">isType</span>, mixed) Types;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Types == meta.Seq!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, string)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="unaryT"></a><u>unaryT</u>(string expr)</div></dt>
<dd>Transforms a string representing a compile-time entity into a unary template
that returns the represented entity.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>expr</td>
<td valign=top>String representing a compile-time entity using a template parameter
        <span class="d_inlinecode">a</span> or <span class="d_inlinecode">A</span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Unary template that evaluates <span class="d_inlinecode">expr</span>.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">unaryT</span>!<span class="d_string">q{ const A }</span> Constify;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Constify!<span class="d_keyword">int</span> == <span class="d_keyword">const</span> <span class="d_keyword">int</span>));

<span class="d_keyword">alias</span> meta.<span class="d_psymbol">unaryT</span>!<span class="d_string">q{ a.length }</span> lengthof;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(lengthof!([ 1,2,3,4,5 ]) == 5);
</pre>

 The generated template can return a sequence.
<pre class="d_code"><span class="d_keyword">import</span> std.meta;
<span class="d_keyword">import</span> std.typecons;

<span class="d_comment">// Extracts the Types property of a Tuple instance.
</span><span class="d_keyword">alias</span> meta.<span class="d_psymbol">unaryT</span>!<span class="d_string">q{ A.Types }</span> expand;

<span class="d_keyword">alias</span> expand!(Tuple!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, string)) Types;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Types[0] == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Types[1] == <span class="d_keyword">double</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Types[2] == string));
</pre>

<p></p>
<b>See Also:</b><br><span class="d_inlinecode">meta.lambda</span><p></p>

</dd>
<dt><div class="d_decl">template <a name="binaryT"></a><u>binaryT</u>(string expr)</div></dt>
<dd>Transforms a string representing a compile-time entity into a binary template
that returns the represented entity.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>expr</td>
<td valign=top>String representing a compile-time entity using two template</td></tr>
</table><p></p>
<b>parameters:</b><br>
<span class="d_inlinecode">a, A</span> as the first one and <span class="d_inlinecode">b, B</span> the second.

<p></p>
<b>Returns:</b><br>Binary template that evaluates <span class="d_inlinecode">expr</span>.

<p></p>
<b>Example:</b><br>
This example uses the first parameter <span class="d_inlinecode">a</span> as a value and the second one
 <span class="d_inlinecode">B</span> as a type, and returns a value.
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">binaryT</span>!<span class="d_string">q{ a + B.sizeof }</span> accumSize;

<span class="d_keyword">enum</span> n1 = accumSize!( 0,    <span class="d_keyword">int</span>);
<span class="d_keyword">enum</span> n2 = accumSize!(n1, <span class="d_keyword">double</span>);
<span class="d_keyword">enum</span> n3 = accumSize!(n2,  <span class="d_keyword">short</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(n3 == 4 + 8 + 2);
</pre>

<p></p>
<b>See Also:</b><br><span class="d_inlinecode">meta.lambda</span><p></p>

</dd>
<dt><div class="d_decl">template <a name="variadicT"></a><u>variadicT</u>(string expr)</div></dt>
<dd>Transforms a string representing an expression into a variadic template.
The expression can read variadic arguments via <span class="d_inlinecode">args</span>.
<p></p>
The expression can also use named parameters as <span class="d_inlinecode">meta.unaryT</span>, but
the number of implicitly-named parameters is limited up to eight:
<span class="d_inlinecode">a, b, c, d, e, f, g</span> and <span class="d_inlinecode">h</span> (plus capitalized ones) depending
on the number of arguments.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>fun</td>
<td valign=top>Expression string or template declaration.  The string may use
       named parameters <span class="d_inlinecode">a</span> to <span class="d_inlinecode">h</span>, <span class="d_inlinecode">A</span> to <span class="d_inlinecode">H</span> and <span class="d_inlinecode">args</span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Variadic template that evaluates <span class="d_inlinecode">fun</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">variadicT</span>!<span class="d_string">q{ meta.Seq!(args[1 .. $], A) }</span> rotate1;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>([ rotate1!(1, 2, 3, 4) ] == [ 2, 3, 4, 1 ]);
</pre>

<p></p>
<b>See Also:</b><br><span class="d_inlinecode">meta.lambda</span><p></p>

</dd>
<dt><div class="d_decl">template <a name="lambda"></a><u>lambda</u>(string decl,captures...)</div></dt>
<dd>Transforms a string representing a template body into a variadic template.
<p></p>
<span class="d_inlinecode">meta.<a name="lambda"></a><u>lambda</u></span> is much like <span class="d_inlinecode">meta.variadicT</span> as it's variadic and
parameters can be accessed via <span class="d_inlinecode">args</span> and <span class="d_inlinecode">a</span>-<span class="d_inlinecode">h</span>.  In addition,
<span class="d_inlinecode">meta.<a name="lambda"></a><u>lambda</u></span> also supports recursions and local entity captures.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>decl</td>
<td valign=top>String representing a valid template body.  The body must
            declare a symbol <span class="d_inlinecode">_</span> that represents the result of the
            template.  The result can be overloaded if it's a function
            or a template.
<p></p>

            The body may use named parameters <span class="d_inlinecode">a</span> to <span class="d_inlinecode">h</span>, <span class="d_inlinecode">A</span> to
            <span class="d_inlinecode">H</span> and <span class="d_inlinecode">args</span>.  Also, named captures <span class="d_inlinecode">p</span> to <span class="d_inlinecode">w</span>,
            <span class="d_inlinecode">P</span> to <span class="d_inlinecode">W</span> and <span class="d_inlinecode">captures</span> are available.
<p></p>

            The body may use a symbol <span class="d_inlinecode"><a name="lambda"></a><u>lambda</u></span> that refers to the
            generated template itself.</td></tr>
<tr><td valign=top>captures</td>
<td valign=top>Local compile-time entities (types, values, templates etc.) to
            make available in the generated template.</td></tr>
</table><p></p>
<b>Returns:</b><br>Variadic template whose body is <span class="d_inlinecode">decl</span> and evaluates to <span class="d_inlinecode">_</span> declared
 in the body.

<p></p>
<b>Recursion:</b><br>
The generated template itself is accessible from the string using an
 identifier <span class="d_inlinecode"><a name="lambda"></a><u>lambda</u></span>, and you can define recursive templates:
<pre class="d_code"><span class="d_comment">// Remove pointer 'stars' from every type in a sequence.  The generated
</span><span class="d_comment">// template is passed to meta.map as a transoformer template.
</span><span class="d_keyword">alias</span> meta.map!(meta.<span class="d_psymbol">lambda</span>!(
                   <span class="d_string">q{
                        static if (is(A T == T*))
                        {
                            alias lambda!T _;   // recursion
                        }
                        else
                        {
                            alias        A _;
                        }
                    }</span>),
                <span class="d_keyword">int</span>*, <span class="d_keyword">void</span>**, <span class="d_keyword">short</span>, <span class="d_keyword">double</span>***) NoPointers;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(NoPointers[0] == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(NoPointers[1] == <span class="d_keyword">void</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(NoPointers[2] == <span class="d_keyword">short</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(NoPointers[3] == <span class="d_keyword">double</span>));
</pre>

<p></p>
<b>Captures:</b><br>
The template generated by <span class="d_inlinecode">meta.<a name="lambda"></a><u>lambda</u></span> can use local entities
 explicitly passed via the <span class="d_inlinecode">captures</span> parameter.  Like template
 parameters, captured entities get named <span class="d_inlinecode">p</span>-<span class="d_inlinecode">w</span> and <span class="d_inlinecode">P</span>-<span class="d_inlinecode">W</span>.
<pre class="d_code"><span class="d_keyword">struct</span> Example(T, UU...)
{
    <span class="d_comment">// Check if UU contains a type that implicitly convertible to T,
</span>    <span class="d_comment">// and issues an error if so.
</span>    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (meta.any!(meta.<span class="d_psymbol">lambda</span>!(
                            <span class="d_string">q{
                                 enum _ = is(A : P);
                             }</span>,
                             T),    <span class="d_comment">// T is captured as 'P'
</span>                         UU))
    {
        <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(0, <span class="d_string">"At least one type in "</span>~ UU.stringof ~<span class="d_string">" is "</span>
                        ~<span class="d_string">"implicitly convertible to "</span>~ T.stringof);
    }
}
Example!(<span class="d_keyword">int</span>, string, <span class="d_keyword">double</span>) Okay;
Example!(<span class="d_keyword">int</span>, string,   <span class="d_keyword">bool</span>) Error;    <span class="d_comment">// Convertible: bool -&gt; int
</span></pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="bind"></a><u>bind</u>(alias templat,args...)</div></dt>
<dd>Binds <span class="d_inlinecode">args</span> to the leftmost parameters of a template <span class="d_inlinecode">templat</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>templat</td>
<td valign=top>Template or string that can be tranformed to a variadic template
           using <span class="d_inlinecode">meta.variadicT</span>.</td></tr>
<tr><td valign=top>args</td>
<td valign=top>Zero or more template instantiation arguments to <a name="bind"></a><u>bind</u>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Template that instantiates <span class="d_inlinecode">templat</span> with the bound arguments and
 additional ones as <span class="d_inlinecode">templat!(args, ...)</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">template</span> compareSize(T, U)
{
    <span class="d_keyword">enum</span> compareSize = T.sizeof &lt; U.sizeof;
}

<span class="d_comment">// Get the types satisfying "int.sizeof &lt; U.sizeof".
</span><span class="d_keyword">alias</span> meta.filter!(meta.<span class="d_psymbol">bind</span>!(compareSize, <span class="d_keyword">int</span>),
                   <span class="d_keyword">byte</span>, <span class="d_keyword">double</span>, <span class="d_keyword">short</span>, <span class="d_keyword">int</span>, <span class="d_keyword">long</span>) Result;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Result == meta.Seq!(<span class="d_keyword">double</span>, <span class="d_keyword">long</span>) ));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="rbind"></a><u>rbind</u>(alias templat,args...)</div></dt>
<dd>Same as <span class="d_inlinecode">meta.bind</span> except that <span class="d_inlinecode">meta.<a name="rbind"></a><u>rbind</u></span> binds arguments to
rightmost parameters.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>templat</td>
<td valign=top>Template or string that can be tranformed to a variadic template
           using <span class="d_inlinecode">meta.variadicT</span>.</td></tr>
<tr><td valign=top>args</td>
<td valign=top>Zero or more template instantiation arguments to bind.</td></tr>
</table><p></p>
<b>Returns:</b><br>Template that instantiates <span class="d_inlinecode">templat</span> with the bound arguments and
 additional ones as <span class="d_inlinecode">templat!(..., args)</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">template</span> compareSize(T, U)
{
    <span class="d_keyword">enum</span> compareSize = T.sizeof &lt; U.sizeof;
}

<span class="d_comment">// Get the types satisfying "T.sizeof &lt; int.sizeof"
</span><span class="d_keyword">alias</span> meta.filter!(meta.<span class="d_psymbol">rbind</span>!(compareSize, <span class="d_keyword">int</span>),
                   <span class="d_keyword">byte</span>, <span class="d_keyword">double</span>, <span class="d_keyword">short</span>, <span class="d_keyword">int</span>, <span class="d_keyword">long</span>) Result;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Result == meta.Seq!(<span class="d_keyword">byte</span>, <span class="d_keyword">short</span>) ));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="fix"></a><u>fix</u>(alias templat,args...)</div></dt>
<dd>Binds <span class="d_inlinecode">args</span> to all the parameters of <span class="d_inlinecode">templat</span>.  Generated template
will instantiate <span class="d_inlinecode">templat</span> with just the bound arguments.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>templat</td>
<td valign=top>Template or string to instantiate.</td></tr>
<tr><td valign=top>args</td>
<td valign=top>Complete arguments for <span class="d_inlinecode">templat</span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Variadic template that constantly returns <span class="d_inlinecode">templat!args</span> regardless of
 its arguments.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.fixed!(meta.Id, <span class="d_keyword">int</span>) intFixed;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(intFixed!() == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(intFixed!(<span class="d_keyword">void</span>) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(intFixed!(1,2,3) == <span class="d_keyword">int</span>));
</pre>

 Using fixed template for a fallback case of <span class="d_inlinecode">meta.guard</span>:
<pre class="d_code"><span class="d_keyword">struct</span> Error;

<span class="d_keyword">alias</span> meta.guard!(<span class="d_string">q{ A[] }</span>, meta.<span class="d_psymbol">fix</span>!(meta.Id, Error)) Array;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Array!<span class="d_keyword">int</span> == <span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Array!100 == Error));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="not"></a><u>not</u>(alias pred)<br>template <a name="not"></a><u>not</u>(string pred)</div></dt>
<dd>Creates a predicate template that inverts the result of the given one.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Predicate template or expression string to invert.  The result
        must be a compile-time value that is implicitly convertible to
        <span class="d_inlinecode">bool</span> in conditional expressions.</td></tr>
</table><p></p>
<b>Returns:</b><br>Template that evaluates <span class="d_inlinecode">pred</span> and returns an inverted result.

<p></p>
<b>Example:</b><br>
Passing an inverted predicate to the <span class="d_inlinecode">meta.countBy</span>.
<pre class="d_code"><span class="d_keyword">template</span> isStruct(T)
{
    <span class="d_keyword">enum</span> isStruct = <span class="d_keyword">is</span>(T == <span class="d_keyword">struct</span>) || <span class="d_keyword">is</span>(T == <span class="d_keyword">union</span>);
}

<span class="d_keyword">struct</span> S {}
<span class="d_keyword">union</span>  U {}
<span class="d_keyword">class</span>  C {}

<span class="d_comment">// Count non-struct types in the sequence.
</span><span class="d_keyword">enum</span> n = meta.countBy!(meta.<span class="d_psymbol">not</span>!isStruct,
                       <span class="d_keyword">int</span>, <span class="d_keyword">double</span>, S, U, C);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(n == 3);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="and"></a><u>and</u>(preds...)</div></dt>
<dd>Composes predicate templates with the logical <span class="d_inlinecode">&amp;&amp;</span> operator.
<p></p>
The predicates will be evaluated in the same order as passed to this
template.  The evaluations are lazy; if one of the predicates is not
satisfied, <span class="d_inlinecode">meta.<a name="and"></a><u>and</u></span> immediately returns <span class="d_inlinecode"><b>false</b></span> without evaluating
remaining predicates.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>preds</td>
<td valign=top>Zero or more predicate templates to compose.  This argument can be
         empty; in that case, the resulting template constantly evaluates to
         <span class="d_inlinecode"><b>true</b></span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Composition predicate template that tests if its arguments satisfy all the
 predicates <span class="d_inlinecode">preds</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">template</span> isIntegral(T)
{
    <span class="d_keyword">enum</span> isIntegral = meta.any!(meta.isSame!T,
                                <span class="d_keyword">byte</span>, <span class="d_keyword">short</span>, <span class="d_keyword">int</span>, <span class="d_keyword">long</span>,
                                <span class="d_keyword">ubyte</span>, <span class="d_keyword">ushort</span>, <span class="d_keyword">uint</span>, <span class="d_keyword">ulong</span>);
}

<span class="d_comment">// Look for a tiny integral type: byte.
</span><span class="d_keyword">enum</span> k = meta.indexBy!(meta.<span class="d_psymbol">and</span>!(isIntegral, <span class="d_string">q{ A.sizeof &lt; 4 }</span>),
                       <span class="d_keyword">int</span>, <span class="d_keyword">void</span>, <span class="d_keyword">double</span>, <span class="d_keyword">byte</span>, string);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(k == 3);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="or"></a><u>or</u>(preds...)</div></dt>
<dd>Composes predicate templates with the logical <span class="d_inlinecode">||</span> operator.
<p></p>
The predicates will be evaluated in the same order as passed to this
template.  The evaluations are lazy; if one of the predicates is
satisfied, <span class="d_inlinecode">meta.<a name="or"></a><u>or</u></span> immediately returns <span class="d_inlinecode"><b>true</b></span> without evaluating
remaining predicates.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>preds</td>
<td valign=top>Zero <a name="or"></a><u>or</u> more predicate templates to compose.  This argument can be
         empty; in that case, the resulting template constantly evaluates to
         <span class="d_inlinecode"><b>false</b></span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Composition predicate template that tests if its arguments satisfy at least
 one of the predicates <span class="d_inlinecode">preds</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Note that bool doesn't have the .min property.
</span><span class="d_keyword">alias</span> meta.filter!(meta.<span class="d_psymbol">or</span>!(<span class="d_string">q{ A.sizeof &lt; 4 }</span>, <span class="d_string">q{ A.min &lt; 0 }</span>),
                   <span class="d_keyword">bool</span>, <span class="d_keyword">ushort</span>, <span class="d_keyword">int</span>, <span class="d_keyword">uint</span>) R;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(R == meta.Seq!(<span class="d_keyword">bool</span>, <span class="d_keyword">ushort</span>, <span class="d_keyword">int</span>)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="compose"></a><u>compose</u>(templates...) if (templates.length &gt; 0)</div></dt>
<dd><span class="d_inlinecode"><a name="compose"></a><u>compose</u>!(t1, t2, ..., tn)</span> returns a variadic template that in turn
instantiates the passed in templates in a chaining way:
<pre class="d_code"><span class="d_keyword">template</span> composition(args...)
{
    <span class="d_keyword">alias</span> t1!(t2!( ... tn!(args) ... )) composition;
}
</pre>
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>templates</td>
<td valign=top>One or more templates making up the chain.  Each template
             can be a template or a string; strings are transformed to
             varadic templates using <span class="d_inlinecode">meta.variadicT</span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>New template that instantiates the chain of <span class="d_inlinecode">templates</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">compose</span>!(<span class="d_string">q{ A[] }</span>,
                    <span class="d_string">q{ const A }</span>) ConstArray;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(ConstArray!<span class="d_keyword">int</span> == <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[]));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="guard"></a><u>guard</u>(templates...) if (templates.length &gt; 0)</div></dt>
<dd>Generates a template that tries instantiating specified templates in turn
and returns the result of the first compilable template.
<p></p>
For example, <span class="d_inlinecode">meta.<a name="guard"></a><u>guard</u>!(t1, t2)</span> generates a template that behaves
as follows:
<pre class="d_code"><span class="d_keyword">template</span> trial(args...)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">__traits</span>(compiles, t1!(args)))
    {
        <span class="d_keyword">alias</span> t1!(args) trial;
    }
    <span class="d_keyword">else</span>
    {
        <span class="d_keyword">alias</span> t2!(args) trial;
    }
}
</pre>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>templates</td>
<td valign=top>Templates to try instantiation.  Each template can be a real
             template or a string that can be transformed to a template
             using <span class="d_inlinecode">meta.variadicT</span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Variadic template that instantiates the first compilable template among
 <span class="d_inlinecode">templates</span>.  The last template is not guarded; if all the templates
 failed, the generated template will fail due to the last one.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">guard</span>!(<span class="d_string">q{ A.min &lt; 0 }</span>, <span class="d_string">q{ false }</span>) hasNegativeMin;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( hasNegativeMin!<span class="d_keyword">int</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!hasNegativeMin!<span class="d_keyword">uint</span>);    <span class="d_comment">// uint.min is non-negative
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!hasNegativeMin!<span class="d_keyword">void</span>);    <span class="d_comment">// void.min is not defined
</span></pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="expand"></a><u>expand</u>(alias arr)</div></dt>
<dd>Expands a compile-time array to a sequence of the elements.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>arr</td>
<td valign=top>Compile-time expression of an array.  The array can be dynamic or
       static, but its length and elements must be known at compile-time.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of the elements of <span class="d_inlinecode">arr</span>.

<p></p>
<b>Example:</b><br>
Using <span class="d_inlinecode">meta.<a name="expand"></a><u>expand</u></span> to apply a meta algorithm <span class="d_inlinecode">meta.map</span> on
 elements of a compile-time array.
<pre class="d_code"><span class="d_comment">// Array of function names.
</span><span class="d_keyword">enum</span> functions = [ <span class="d_string">"fun"</span>, <span class="d_string">"gun"</span>, <span class="d_string">"hun"</span> ];

<span class="d_comment">// Use meta.map to transform the function names into signatures with
</span><span class="d_comment">// help of meta.expand.
</span><span class="d_keyword">alias</span> meta.map!(meta.lambda!(
                   <span class="d_string">q{
                        // Make a signature of a variadic function of
                        // the given name 'a'.
                        enum _ = "auto "~ a ~"(Args...)(Args args)";
                    }</span>),
                meta.<span class="d_psymbol">expand</span>!functions) signatures;
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="expand"></a><u>expand</u>(Arr : Arr[n],size_t n)</div></dt>
<dd>Expands a static array type into a sequence of its element types.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Arr</td>
<td valign=top>Type of a static array.</td></tr>
<tr><td valign=top>n</td>
<td valign=top>The length of the static array; it's automatically deduced by the
       language when instantiating this template.</td></tr>
</table><p></p>
<b>Returns:</b><br>The element type of <span class="d_inlinecode">Arr</span> repeated <span class="d_inlinecode">n</span> times.  The empty sequence is
 returned if <span class="d_inlinecode">n == 0</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">expand</span>!(<span class="d_keyword">int</span>[4]) int4;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Tag!int4 == Tag!(<span class="d_keyword">int</span>, <span class="d_keyword">int</span>, <span class="d_keyword">int</span>, <span class="d_keyword">int</span>)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="iota"></a><u>iota</u>(alias beg,alias end,alias step) if (step &lt;&gt; 0)<br>template <a name="iota"></a><u>iota</u>(alias beg,alias end)<br>template <a name="iota"></a><u>iota</u>(alias end)</div></dt>
<dd>Yields a sequence of numbers starting from <span class="d_inlinecode">beg</span> to <span class="d_inlinecode">end</span> with the
specified <span class="d_inlinecode">step</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>beg</td>
<td valign=top>Compile-time numeral value (<span class="d_inlinecode">0</span> if not specified).  The
        resulting sequence starts with <span class="d_inlinecode">beg</span> if not empty.</td></tr>
<tr><td valign=top>end</td>
<td valign=top>Compile-time numeral value.  The resulting sequence stops before
        <span class="d_inlinecode">end</span> and never contain it.</td></tr>
<tr><td valign=top>step</td>
<td valign=top>Compile-time numeral value (<span class="d_inlinecode">1</span> if not specified).  The
        resulting sequence increases or decreases by <span class="d_inlinecode">step</span>.  The
        step may not be zero.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of compile-time numbers starting from <span class="d_inlinecode">beg</span> to <span class="d_inlinecode">end</span>,
 increasing/decreasing by <span class="d_inlinecode">step</span>.  The type of each element is the
 common type of <span class="d_inlinecode">beg</span> and <span class="d_inlinecode">end</span>.

<p></p>
<b>Examples:</b><br>Using <span class="d_inlinecode">meta.<a name="iota"></a><u>iota</u></span> to fill a constant array:
<pre class="d_code"><span class="d_keyword">static</span> <span class="d_keyword">immutable</span> <span class="d_keyword">int</span>[] sequence = [ meta.<span class="d_psymbol">iota</span>!(9, 99, 9) ];
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(sequence == [ 9, 18, 27, 36, 45, 54, 63, 72, 81, 90 ]);
</pre>

 Next example shows a static foreach.  The variable <span class="d_inlinecode">i</span> in the
 following code holds a compile-time value.
<pre class="d_code"><span class="d_comment">// Declare arrays of int[4], int[5], int[6] and int[7].
</span><span class="d_keyword">foreach</span> (i; meta.<span class="d_psymbol">iota</span>!(4, 8))
{
    <span class="d_keyword">int</span>[i] array;
}
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="iterate"></a><u>iterate</u>(size_t n,alias fun,seed...)</div></dt>
<dd>TODO
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>n</td>
<td valign=top>.</td></tr>
<tr><td valign=top>fun</td>
<td valign=top>.</td></tr>
<tr><td valign=top>seed</td>
<td valign=top>.</td></tr>
</table><p></p>
<b>Returns:</b><br>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Pointers = (int, int*, int**, int***)
</span><span class="d_keyword">alias</span> meta.<span class="d_psymbol">iterate</span>!(4, <span class="d_string">q{ A* }</span>, <span class="d_keyword">int</span>) Pointers;
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="repeat"></a><u>repeat</u>(size_t n,seq...)</div></dt>
<dd>Creates a sequence in which <span class="d_inlinecode">seq</span> repeats <span class="d_inlinecode">n</span> times.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>n</td>
<td valign=top>The number of repetition.  May be zero.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to repeat.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence composed of <span class="d_inlinecode">n</span> <span class="d_inlinecode">seq</span>s.  The empty sequence is returned
 if <span class="d_inlinecode">n</span> is zero or <span class="d_inlinecode">seq</span> is empty.

<p></p>
<b>Example:</b><br>
Filling a continuous region in a table with specific values.
<pre class="d_code"><span class="d_keyword">enum</span> CharType { other, digit, alpha }

<span class="d_keyword">static</span> <span class="d_keyword">immutable</span> CharType[256] charTypeTab =
[
    '0': meta.<span class="d_psymbol">repeat</span>!(10, CharType.digit),
    'A': meta.<span class="d_psymbol">repeat</span>!(26, CharType.alpha),
    'a': meta.<span class="d_psymbol">repeat</span>!(26, CharType.alpha),
];
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(charTypeTab['M'] == CharType.alpha);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="swapAt"></a><u>swapAt</u>(size_t i,size_t j,seq...)</div></dt>
<dd>Swaps <span class="d_inlinecode">i</span>-th and <span class="d_inlinecode">j</span>-th elements of <span class="d_inlinecode">seq</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>i</td>
<td valign=top>Valid index for <span class="d_inlinecode">seq</span>.</td></tr>
<tr><td valign=top>j</td>
<td valign=top>ditto.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Target sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br><span class="d_inlinecode">seq</span> in which <span class="d_inlinecode">seq[i]</span> and <span class="d_inlinecode">seq[j]</span> are replaced with each other.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">byte</span>, <span class="d_keyword">short</span>, <span class="d_keyword">int</span>, <span class="d_keyword">long</span>) Types;

<span class="d_comment">// Swap short and int.
</span><span class="d_keyword">alias</span> meta.<span class="d_psymbol">swapAt</span>!(1, 2, Types) Swapped;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Swapped == meta.Seq!(<span class="d_keyword">byte</span>, <span class="d_keyword">int</span>, <span class="d_keyword">short</span>, <span class="d_keyword">long</span>)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="extract"></a><u>extract</u>(alias indices,seq...)</div></dt>
<dd>Extracts elements at the specified positions out of <span class="d_inlinecode">seq</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>indices</td>
<td valign=top>Compile-time array of indices designating elements to extract.
           Each index must be less than <span class="d_inlinecode">seq.length</span> and implicitly
           convertible to <span class="d_inlinecode">size_t</span>.  Duplicate indices are allowed.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Source sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of elements extracted from <span class="d_inlinecode">seq</span>.  The order of the elements
 is the same as that of corresponding indices in <span class="d_inlinecode">indices</span>.  The length
 of the result is the same as that of <span class="d_inlinecode">indices</span>, and the empty sequence
 is returned if <span class="d_inlinecode">indices</span> is empty.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">double</span>, <span class="d_string">"value"</span>, 5.0) seq;
<span class="d_keyword">alias</span> meta.<span class="d_psymbol">extract</span>!([ 0, 2 ], seq) extracted;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(extracted.length == 2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(extracted[0] == <span class="d_keyword">double</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(   extracted[1] == 5.0    );
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="reverse"></a><u>reverse</u>(seq...)</div></dt>
<dd>Reverses the sequence <span class="d_inlinecode">seq</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>seq</td>
<td valign=top>Sequence to reverse.</td></tr>
</table><p></p>
<b>Returns:</b><br><span class="d_inlinecode">seq</span> in the reverse order.  The empty sequence is returned if <span class="d_inlinecode">seq</span>
 is empty.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">reverse</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, string) Rev;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Rev == meta.Seq!(string, <span class="d_keyword">double</span>, <span class="d_keyword">int</span>)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="rotate"></a><u>rotate</u>(sizediff_t n,seq...)</div></dt>
<dd>Rotates <span class="d_inlinecode">seq</span> by <span class="d_inlinecode">n</span>.  The result is, conceptually,
<span class="d_inlinecode">(seq[n .. $], seq[0 .. n])</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>n</td>
<td valign=top>The amount of rotation.  The sign determines the direction:
       positive for left rotation and negative for right rotation.
       This parameter can be zero or larger than <span class="d_inlinecode">seq.length</span>.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to rotate.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence <span class="d_inlinecode">seq</span> rotated by <span class="d_inlinecode">n</span>.  The empty sequence is returned
 if <span class="d_inlinecode">seq</span> is empty.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="stride"></a><u>stride</u>(size_t n,seq...) if (n &gt;= 1)</div></dt>
<dd>Picks up elements of sequence with stride <span class="d_inlinecode">n</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>n</td>
<td valign=top>Stride width.  <span class="d_inlinecode">n</span> may not be zero.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to stride.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of <span class="d_inlinecode">0,n,2n,...</span>-th elements of the given sequence:
 <span class="d_inlinecode">(seq[0], seq[n], seq[2*n], ...)</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="segment"></a><u>segment</u>(size_t n,seq...) if (n &gt;= 1)</div></dt>
<dd>Splits sequence <span class="d_inlinecode">seq</span> into segments of length <span class="d_inlinecode">n</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>n</td>
<td valign=top>The size of each segment. <span class="d_inlinecode">n</span> may not be zero.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to segment.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of packed segments of length <span class="d_inlinecode">n</span>.  The last segment can
 be shorter than <span class="d_inlinecode">n</span> if <span class="d_inlinecode">seq.length</span> is not a multiple of <span class="d_inlinecode">n</span>.

<p></p>
<b>Example:</b><br>
<span class="d_inlinecode">meta.<a name="segment"></a><u>segment</u></span> would be useful to scan simple patterns out of
 template parameters or other sequences.
<pre class="d_code"><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">int</span>,    <span class="d_string">"x"</span>, 10,
                <span class="d_keyword">double</span>, <span class="d_string">"y"</span>, 20) config;

<span class="d_keyword">alias</span> meta.<span class="d_psymbol">segment</span>!(3, config) patterns;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(meta.isSame!(patterns[0], meta.pack!(<span class="d_keyword">int</span>,    <span class="d_string">"x"</span>, 10)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(meta.isSame!(patterns[1], meta.pack!(<span class="d_keyword">double</span>, <span class="d_string">"y"</span>, 20)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="segmentWith"></a><u>segmentWith</u>(alias fun,size_t n,seq...) if (n &gt;= 1)<br>template <a name="segmentWith"></a><u>segmentWith</u>(string fun,size_t n,seq...) if (n &gt;= 1)</div></dt>
<dd>Generalization of the <span class="d_inlinecode">meta.segment</span>.  It passes each segment to
<span class="d_inlinecode">fun</span> instead of the <span class="d_inlinecode">meta.pack</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>fun</td>
<td valign=top><span class="d_inlinecode">n</span>-ary template.</td></tr>
<tr><td valign=top>n</td>
<td valign=top>The size of each segment. <span class="d_inlinecode">n</span> may not be zero.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to segment.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of the results of <span class="d_inlinecode">fun</span> applied to each segment.

<p></p>
<b>Example:</b><br>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="interleave"></a><u>interleave</u>(seqs...)</div></dt>
<dd>TODO
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>seqs</td>
<td valign=top></td></tr>
</table><p></p>
<b>Returns:</b><br>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="transverse"></a><u>transverse</u>(size_t i,seqs...) if (all!(and!(isPacked,isLongerThan!(i)),seqs))</div></dt>
<dd>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>i</td>
<td valign=top>.</td></tr>
<tr><td valign=top>seqs</td>
<td valign=top>.</td></tr>
</table><p></p>
<b>Returns:</b><br>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="zip"></a><u>zip</u>(seqs...) if (all!(isPacked,seqs))</div></dt>
<dd>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>seqs</td>
<td valign=top>Sequence of packed sequences.</td></tr>
</table><p></p>
<b>Returns:</b><br>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="zipWith"></a><u>zipWith</u>(alias fun,seqs...) if (all!(isPacked,seqs))<br>template <a name="zipWith"></a><u>zipWith</u>(string fun,seqs...) if (all!(isPacked,seqs))</div></dt>
<dd>Generalization of the <span class="d_inlinecode">meta.zip</span>.  It zippes elements with <span class="d_inlinecode">fun</span>
instead of the <span class="d_inlinecode">meta.pack</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>fun</td>
<td valign=top>Template or expression string of arity <span class="d_inlinecode">seqs.length</span>.</td></tr>
<tr><td valign=top>seqs</td>
<td valign=top>Sequence of packed sequences.</td></tr>
</table><p></p>
<b>Returns:</b><br>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="cartesian"></a><u>cartesian</u>(seqs...) if (seqs.length &gt;= 1 &amp;&amp; all!(isPacked,seqs))</div></dt>
<dd>Generates a sequence of the cartesian product of packed sequences.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>seqs</td>
<td valign=top>One or more packed sequences.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of packed sequences, each of which is composed of a combination
 of the elements from the input sequences.  The empty sequence is returned
 if at least one sequence in <span class="d_inlinecode">seqs</span> is empty.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Test nine cases of floating-point to string conversions.
</span><span class="d_keyword">foreach</span> (Comb; meta.<span class="d_psymbol">cartesian</span>!(meta.pack!(<span class="d_keyword">float</span>, <span class="d_keyword">double</span>, <span class="d_keyword">real</span>),
                               meta.pack!(string, wstring, dstring)))
{
    <span class="d_keyword">alias</span> Comb.expand[0] Source;
    <span class="d_keyword">alias</span> Comb.expand[1] Target;

    Source value = 0;
    <span class="d_keyword">assert</span>(std.conv.to!Target(value) == <span class="d_string">"0"</span>);
}
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="map"></a><u>map</u>(alias fun,seq...)<br>template <a name="map"></a><u>map</u>(string fun,seq...)</div></dt>
<dd>Transforms a sequence <span class="d_inlinecode">seq</span> into <span class="d_inlinecode">(fun!(seq[0]), fun!(seq[1]), ...)</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>fun</td>
<td valign=top>Unary template or expression string that maps each element of
       <span class="d_inlinecode">seq</span> into another compile-time entity.  Its result may also
       be a sequence of any length.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence of compile-time entities.</td></tr>
</table><p></p>
<b>Returns:</b><br>.

<p></p>
<b>Examples:</b><br>Map types into pointers.
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">map</span>!(<span class="d_string">q{ A* }</span>, <span class="d_keyword">int</span>, <span class="d_keyword">double</span>, <span class="d_keyword">void</span>*) PP;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(PP[0] ==    <span class="d_keyword">int</span>*));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(PP[1] == <span class="d_keyword">double</span>*));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(PP[2] ==  <span class="d_keyword">void</span>**));
</pre>

 Doubling elements by passing a template returning a sequence.
<pre class="d_code"><span class="d_comment">// Twice = (int, int, bool, bool, string, string)
</span><span class="d_keyword">alias</span> meta.<span class="d_psymbol">map</span>!(meta.bind!(meta.repeat, 2),
                <span class="d_keyword">int</span>, <span class="d_keyword">bool</span>, string) Twice;
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="filter"></a><u>filter</u>(alias pred,seq...)<br>template <a name="filter"></a><u>filter</u>(string pred,seq...)</div></dt>
<dd>Filters those items satisfying <span class="d_inlinecode">pred</span> out of a sequence <span class="d_inlinecode">seq</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>fun</td>
<td valign=top>Unary template or expression string that maps a compile-time
       entity into a boolean value.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence of compile-time entities.</td></tr>
</table><p></p>
<b>Returns:</b><br>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="remove"></a><u>remove</u>(E,seq...)<br>template <a name="remove"></a><u>remove</u>(alias E,seq...)</div></dt>
<dd>Removes all occurrences of <span class="d_inlinecode">E</span> in <span class="d_inlinecode">seq</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>E</td>
<td valign=top>Compile-time entity to <a name="remove"></a><u>remove</u> from <span class="d_inlinecode">seq</span>.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of elements of <span class="d_inlinecode">seq</span> except <span class="d_inlinecode">E</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="removeBy"></a><u>removeBy</u>(alias pred,seq...)</div></dt>
<dd>Removes any elements of <span class="d_inlinecode">seq</span> satisfying the predicate <span class="d_inlinecode">pred</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Unary predicate template or expression string that evaluates
        each element of <span class="d_inlinecode">seq</span> as a boolean value.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of elements of <span class="d_inlinecode">seq</span> not satisfying <span class="d_inlinecode">pred</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="partition"></a><u>partition</u>(alias pred,seq...)</div></dt>
<dd>Partitions <span class="d_inlinecode">seq</span> into two sequences <span class="d_inlinecode">.accepted</span> and <span class="d_inlinecode">.rejected</span>
which do and do not satisfy <span class="d_inlinecode">pred</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Unary predicate template or expression string.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to partition.</td></tr>
</table><p></p>
<b>Returns:</b><br>The two sequences <span class="d_inlinecode">.accepted</span> and <span class="d_inlinecode">.rejected</span>.

<p></p>
<b>Example:</b><br>
Partitioning a sequence of types into interface and others.
<pre class="d_code"><span class="d_keyword">class</span> C {}
<span class="d_keyword">interface</span> I {}
<span class="d_keyword">abstract</span> <span class="d_keyword">class</span> A {}

<span class="d_keyword">alias</span> meta.<span class="d_psymbol">partition</span>!(<span class="d_string">q{ is(A == interface) }</span>, C, I, A) result;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(result.accepted == meta.Seq!(I   )));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(result.rejected == meta.Seq!(C, A)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="replace"></a><u>replace</u>(From,To,seq...)<br>template <a name="replace"></a><u>replace</u>(alias From,To,seq...)<br>template <a name="replace"></a><u>replace</u>(From,alias To,seq...)<br>template <a name="replace"></a><u>replace</u>(alias From,alias To,seq...)</div></dt>
<dd>Replaces all occurrences of <span class="d_inlinecode">From</span> in <span class="d_inlinecode">seq</span> with <span class="d_inlinecode">To</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>From</td>
<td valign=top>Compile-time entity to remove from <span class="d_inlinecode">seq</span>.</td></tr>
<tr><td valign=top>To</td>
<td valign=top>Compile-time entity to insert in place of <span class="d_inlinecode">From</span>.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to perform replacement.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence <span class="d_inlinecode">seq</span> in which all occurrences of <span class="d_inlinecode">From</span> are replaced
 with <span class="d_inlinecode">To</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="sortBy"></a><u>sortBy</u>(alias comp,seq...)<br>template <a name="sortBy"></a><u>sortBy</u>(string comp,seq...)</div></dt>
<dd>Stable sort for compile-time entities.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>comp</td>
<td valign=top>Binary predicate template or expression string that gives an
        ordering to elements of <span class="d_inlinecode">seq</span>.  It typically works as the
        <span class="d_inlinecode">&lt;</span> operator to arrange the result in increasing order.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to sort.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence <span class="d_inlinecode">seq</span> sorted in terms of the ordering <span class="d_inlinecode">comp</span>.
<p></p>

 The sorting algorithm is stable, so the relative order of equivalent
 elements of <span class="d_inlinecode">seq</span> will be preserved.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="isSortedBy"></a><u>isSortedBy</u>(alias comp,seq...)<br>template <a name="isSortedBy"></a><u>isSortedBy</u>(string comp,seq...)</div></dt>
<dd>Determines if <span class="d_inlinecode">seq</span> is sorted in terms of the ordering <span class="d_inlinecode">comp</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>comp</td>
<td valign=top>.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>.</td></tr>
</table><p></p>
<b>Returns:</b><br>.  <span class="d_inlinecode"><b>true</b></span> is returned if <span class="d_inlinecode">seq.length</span> is less than <span class="d_inlinecode">2</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"> .
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="uniq"></a><u>uniq</u>(seq...)</div></dt>
<dd>Removes any consecutive group of duplicate elements in <span class="d_inlinecode">seq</span> except
the first occurrence of each group.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>seq</td>
<td valign=top>Zero or more compile-time entities.</td></tr>
</table><p></p>
<b>Returns:</b><br><span class="d_inlinecode">seq</span> without any consecutive duplicate elements.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">uniq</span>!(1, 2, 3, 3, 4, 4, 4, 2, 2) result;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>([ result ] == [ 1, 2, 3, 4, 2 ]);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="uniqBy"></a><u>uniqBy</u>(alias eq,seq...)<br>template <a name="uniqBy"></a><u>uniqBy</u>(string eq,seq...)</div></dt>
<dd>Generalization of the <span class="d_inlinecode">meta.uniq</span>.<p></p>

</dd>
<dt><div class="d_decl">template <a name="removeDuplicates"></a><u>removeDuplicates</u>(seq...)</div></dt>
<dd>Removes all duplicate elements in <span class="d_inlinecode">seq</span> except the first occurrence.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>seq</td>
<td valign=top>Sequence to eliminate duplicate elements.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence <span class="d_inlinecode">seq</span> without duplicate elements.<p></p>

</dd>
<dt><div class="d_decl">template <a name="removeDuplicatesBy"></a><u>removeDuplicatesBy</u>(alias eq,seq...)</div></dt>
<dd>Generalization of the <span class="d_inlinecode">meta.removeDups</span>.  It detects duplicate
elements with a specified equality instead of the <span class="d_inlinecode">meta.isSame</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>eq</td>
<td valign=top>Binary template that compares parameters for equality.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to eliminate duplicates.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence <span class="d_inlinecode">seq</span> without duplicates in terms of <span class="d_inlinecode">eq</span>.<p></p>

</dd>
<dt><div class="d_decl">template <a name="reduce"></a><u>reduce</u>(alias fun,Seed,seq...)<br>template <a name="reduce"></a><u>reduce</u>(alias fun,alias Seed,seq...)</div></dt>
<dd>Reduces the sequence <span class="d_inlinecode">seq</span> by successively applying a binary template
<span class="d_inlinecode">fun</span> over elements, with an initial state <span class="d_inlinecode">Seed</span>:
<pre class="d_code">fun!( ... fun!(fun!(Seed, seq[0]), seq[1]) ..., seq[$ - 1])
</pre>
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>fun</td>
<td valign=top>Binary template or string.</td></tr>
<tr><td valign=top>Seed</td>
<td valign=top>The initial state.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence of zero or more compile-time entities to reduce.</td></tr>
</table><p></p>
<b>Returns:</b><br>The last result of <span class="d_inlinecode">fun</span>, or <span class="d_inlinecode">Seed</span> if <span class="d_inlinecode">seq</span> is empty.

<p></p>
<b>Example:</b><br>
Computing the net accumulation of the size of types.
<pre class="d_code"><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, <span class="d_keyword">short</span>, <span class="d_keyword">bool</span>, <span class="d_keyword">dchar</span>) Types;

<span class="d_comment">// Note: 'a' gets the "current sum" and 'B' gets a type in the sequence.
</span><span class="d_keyword">enum</span> size = meta.<span class="d_psymbol">reduce</span>!(<span class="d_string">q{ a + B.sizeof }</span>, 0, Types);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(size == 4 + 8 + 2 + 1 + 4);
</pre>

<p></p>
<b>See Also:</b><br><span class="d_inlinecode">meta.scan</span>: <a name="reduce"></a><u>reduce</u> with history.<p></p>

</dd>
<dt><div class="d_decl">template <a name="scan"></a><u>scan</u>(alias fun,Seed,seq...)<br>template <a name="scan"></a><u>scan</u>(alias fun,alias Seed,seq...)</div></dt>
<dd>Returns a sequence generated by successively applying a binary template
<span class="d_inlinecode">fun</span> over the elements of <span class="d_inlinecode">seq</span>, with an initial state <span class="d_inlinecode">Seed</span>:
<pre class="d_code"><span class="d_psymbol">scan</span>[0] = Seed;
<span class="d_psymbol">scan</span>[1] = fun!(<span class="d_psymbol">scan</span>[0], seq[0]);
<span class="d_psymbol">scan</span>[2] = fun!(<span class="d_psymbol">scan</span>[1], seq[1]);
        :
</pre>
Note that <span class="d_inlinecode"><a name="scan"></a><u>scan</u>[i]</span> is equal to <span class="d_inlinecode">meta.reduce!(fun, Seed, seq[0 .. i])</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>fun</td>
<td valign=top>Binary template or string.</td></tr>
<tr><td valign=top>Seed</td>
<td valign=top>The initial state.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence of zero or more compile-time entities to scan.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of the results of <span class="d_inlinecode">fun</span> preceded by <span class="d_inlinecode">Seed</span>.

<p></p>
<b>Example:</b><br>
Computing the sum of the size of types with history.
<pre class="d_code"><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, <span class="d_keyword">short</span>, <span class="d_keyword">bool</span>, <span class="d_keyword">dchar</span>) Types;

<span class="d_keyword">alias</span> meta.<span class="d_psymbol">scan</span>!(<span class="d_string">q{ a + B.sizeof }</span>, 0, Types) sums;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>([ sums ] == [ 0,
                            0+4,
                            0+4+8,
                            0+4+8+2,
                            0+4+8+2+1,
                            0+4+8+2+1+4 ]);
</pre>
 Note that <span class="d_inlinecode">sums[5]</span>, or <span class="d_inlinecode">sums[Types.length]</span>, equals the result
 of the corresponding example of <span class="d_inlinecode">meta.reduce</span>.<p></p>

</dd>
<dt><div class="d_decl">template <a name="most"></a><u>most</u>(alias comp,seq...) if (seq.length &gt; 0)<br>template <a name="most"></a><u>most</u>(string comp,seq...) if (seq.length &gt; 0)</div></dt>
<dd>Looks for the first "top" element of a sequence in terms of the specified
comparison template <span class="d_inlinecode">comp</span>.  This template is effectively the same
as <span class="d_inlinecode">meta.sort!(comp, seq)[0]</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>comp</td>
<td valign=top>Binary template or expression string that compares items in
        the sequence for an ordering.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>One or more compile-time entities.</td></tr>
</table><p></p>
<b>Example:</b><br>
To get the largest element in the sequence, specify a greater-than operator
 as the <span class="d_inlinecode">comp</span> argument.
<pre class="d_code"><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">int</span>, <span class="d_keyword">bool</span>, <span class="d_keyword">double</span>, <span class="d_keyword">short</span>) Types;

<span class="d_comment">// Take the largest type in the sequence: double.
</span><span class="d_keyword">alias</span> meta.<span class="d_psymbol">most</span>!(<span class="d_string">q{ A.sizeof &gt; B.sizeof }</span>, Types) Largest;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Largest == <span class="d_keyword">double</span>));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="find"></a><u>find</u>(E,seq...)<br>template <a name="find"></a><u>find</u>(alias E,seq...)</div></dt>
<dd>Looks for the first occurrence of <span class="d_inlinecode">E</span> in <span class="d_inlinecode">seq</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>E</td>
<td valign=top>Compile-time entity to look for.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to find.</td></tr>
</table><p></p>
<b>Returns:</b><br>Subsequence of <span class="d_inlinecode">seq</span> after <span class="d_inlinecode">E</span> (inclusive).  The empty sequence
 is returned if <span class="d_inlinecode">E</span> is not found.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="findBy"></a><u>findBy</u>(alias pred,seq...)<br>template <a name="findBy"></a><u>findBy</u>(string pred,seq...)</div></dt>
<dd>Same as <span class="d_inlinecode">find</span>, but looks for an item that satisfies a unary predicate.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Unary predicate template or expression string.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to find.</td></tr>
</table><p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="until"></a><u>until</u>(E,seq...)<br>template <a name="until"></a><u>until</u>(alias E,seq...)</div></dt>
<dd>Takes a subsequence of <span class="d_inlinecode">seq</span> <a name="until"></a><u>until</u> encountering <span class="d_inlinecode">E</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>E</td>
<td valign=top>Compile-time entity to look for.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Target sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br>Subsequence of <span class="d_inlinecode">seq</span> before <span class="d_inlinecode">E</span> (exclusive).  The given <span class="d_inlinecode">seq</span> is
 returned as is if <span class="d_inlinecode">E</span> is not found.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="untilBy"></a><u>untilBy</u>(alias pred,seq...)</div></dt>
<dd>Same as <span class="d_inlinecode">until</span>, but stops at an item that satisfies a unary predicate.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Unary predicate template or expression string.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Target sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="index"></a><u>index</u>(E,seq...)<br>template <a name="index"></a><u>index</u>(alias E,seq...)</div></dt>
<dd>Same as evaluating <span class="d_inlinecode">until!(E, seq).length</span> except that <span class="d_inlinecode">-1</span> is
returned if <span class="d_inlinecode">E</span> is not found.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>E</td>
<td valign=top>.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>.</td></tr>
</table><p></p>
<b>Returns:</b><br>.  The type of the result is <span class="d_inlinecode">sizediff_t</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="indexBy"></a><u>indexBy</u>(alias pred,seq...)</div></dt>
<dd>Same as evaluating <span class="d_inlinecode">untilBy!(pred, seq).length</span> except that <span class="d_inlinecode">-1</span> is
returned if no element satisfies the predicate.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>.</td></tr>
</table><p></p>
<b>Returns:</b><br>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="count"></a><u>count</u>(E,seq...)<br>template <a name="count"></a><u>count</u>(alias E,seq...)</div></dt>
<dd>Returns the number of occurrences of <span class="d_inlinecode">E</span> in <span class="d_inlinecode">seq</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>E</td>
<td valign=top>Compile-time entity to look for.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Target sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br>.  The type of the result is <span class="d_inlinecode">size_t</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="countBy"></a><u>countBy</u>(alias pred,seq...)<br>template <a name="countBy"></a><u>countBy</u>(string pred,seq...)</div></dt>
<dd>Same as <span class="d_inlinecode">meta.count</span>, but returns the number of elements that satisfy
the predicate <span class="d_inlinecode">pred</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Unary predicate tempalte or expression string.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Target sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="all"></a><u>all</u>(alias pred,seq...)<br>template <a name="any"></a><u>any</u>(alias pred,seq...)<br>template <a name="none"></a><u>none</u>(alias pred,seq...)</div></dt>
<dd>Determines if, respectively, all/any/none of the elements in a
sequence <span class="d_inlinecode">seq</span> satisfies the predicate <span class="d_inlinecode">pred</span>.  Specifically:
<pre class="d_code"> <span class="d_psymbol">all</span> =  pred!(seq[0]) &amp;&amp;  pred!(seq[1]) &amp;&amp; ... ;
 any =  pred!(seq[0]) ||  pred!(seq[1]) || ... ;
none = !pred!(seq[0]) &amp;&amp; !pred!(seq[1]) &amp;&amp; ... ;
</pre>
<p></p>
These templates evaluate conditions lazily just like usual boolean
expressions, so unnecessary instantiations will never kick in.  For
example, <span class="d_inlinecode">meta.<a name="all"></a><u>all</u></span> immediately returns <span class="d_inlinecode"><b>false</b></span> at first failing
element (if any) and doesn't instantiate <span class="d_inlinecode">pred</span> with remaining
elements.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Unary predicate template or expression string.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Zero or more compile-time entities to examine.</td></tr>
</table><p></p>
<b>Returns:</b><br><span class="d_inlinecode"><b>true</b></span> if all/any/none of the elements of the sequence satisfies
 the predicate.  For the empty sequence, <span class="d_inlinecode">meta.<a name="all"></a><u>all</u></span> and <span class="d_inlinecode">meta.none</span>
 returns <span class="d_inlinecode"><b>true</b></span>; and <span class="d_inlinecode">meta.any</span> returns <span class="d_inlinecode"><b>false</b></span>.

<p></p>
<b>Example:</b><br>
These templates would be useful in template constraints:
<pre class="d_code"><span class="d_keyword">import</span> std.meta, std.range, std.typecons;

<span class="d_comment">// This function requires all arguments should be input ranges.
</span><span class="d_keyword">auto</span> dropFront(Ranges...)(<span class="d_keyword">ref</span> Ranges ranges)
    <span class="d_keyword">if</span> (meta.<span class="d_psymbol">all</span>!(isInputRange, Ranges))
{
    Tuple!(meta.map!(ElementType, Ranges)) result;

    <span class="d_keyword">foreach</span> (i, R; Ranges)
    {
        result[i] = ranges[i].front;
        ranges[i].popFront();
    }
    <span class="d_keyword">return</span> result;
}
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="only"></a><u>only</u>(alias pred,seq...)</div></dt>
<dd>Determines if only one of the elements of <span class="d_inlinecode">seq</span> satisfies the predicate
<span class="d_inlinecode">pred</span>.  The predicate is tested for all the elements.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Unary predicate template or expression string.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Zero or more compile-time entities to examine.</td></tr>
</table><p></p>
<b>Returns:</b><br><span class="d_inlinecode"><b>true</b></span> if <span class="d_inlinecode">seq</span> is not empty and only one of the elements satisfies
 the predicate.  Otherwise, <span class="d_inlinecode"><b>false</b></span> is returned.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Allow only one class in a base class list.
</span><span class="d_keyword">template</span> isValidBase(Bases...)
{
    <span class="d_keyword">enum</span> isValidBase = meta.<span class="d_psymbol">only</span>!(<span class="d_string">q{ is(A == class) }</span>, Bases);
}

<span class="d_keyword">class</span> B {}
<span class="d_keyword">class</span> C {}
<span class="d_keyword">interface</span> I {}
<span class="d_keyword">interface</span> J {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( isValidBase!(B, I, J));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!isValidBase!(B, I, C));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="setIntersection"></a><u>setIntersection</u>(alias A,alias B)</div></dt>
<dd>Set intersection.<p></p>

</dd>
<dt><div class="d_decl">template <a name="setUnion"></a><u>setUnion</u>(alias A,alias B)</div></dt>
<dd>Set union.<p></p>

</dd>
<dt><div class="d_decl">template <a name="setDifference"></a><u>setDifference</u>(alias A,alias B)</div></dt>
<dd>Set difference.<p></p>

</dd>
<dt><div class="d_decl">template <a name="setSymmetricDifference"></a><u>setSymmetricDifference</u>(alias A,alias B)</div></dt>
<dd>Set symmetric difference.<p></p>

</dd>
</dl>

</div>


<div id="copyright">
Copyright Shin Fujishiro 2010.
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
