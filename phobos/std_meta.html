<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>

<!--
	Copyright (c) 1999-2008 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.meta - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="style.css">

<script>
function listanchors()
{
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        if (hash[text] > 0) continue;
        hash[text] = 1;
    values[n++] = a.name
    }

    values.sort();

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        newText += '<a href="#' + a + '"><span class="d_psymbol">'
                + a + '</span></a> ';
    }
    if (newText != "") newText = "<p><b>Jump to:</b> " + newText + '</p>';
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
</script>

</head>

<body onload="listanchors()">
<div id="content">
    <h1>std.meta</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std/internal/meta/meta.d -->
Generic templates and utilities for manipurating compile-time entities
themselves.  Compile-time entities include types, compile-time values,
symbols, and sequences of those entities.
<p></p>
All members in this module are defined in the implicit <span class="d_inlinecode"><a name="meta"></a><u>meta</u></span>
namespace and cannot be used without the <span class="d_inlinecode"><a name="meta"></a><u>meta</u></span> qualifier:
<pre class="d_code"><span class="d_keyword">import</span> std.<span class="d_psymbol">meta</span>;

<span class="d_comment">// Error! reverse is not defined. Use meta.reverse instead.
</span><span class="d_keyword">alias</span> reverse!(<span class="d_string">"x"</span>, 10, <span class="d_string">"y"</span>, 20) Rev;

<span class="d_comment">// Okay, qualified with meta.
</span><span class="d_keyword">alias</span> <span class="d_psymbol">meta</span>.reverse!(<span class="d_string">"x"</span>, 10, <span class="d_string">"y"</span>, 20) Rev;
</pre>

<p></p>
<b>Examples:</b><br><pre class="d_code">TODO
</pre>

<p></p>
<b>Source:</b><br>
<a href="http://github.com/sinfu/phobos-sandbox/blob/master/std/meta.d">std/meta.d</a> (which is just a shell around
             <a href="http://github.com/sinfu/phobos-sandbox/blob/master/std/internal/meta/meta.d">std/internal/meta/meta.d</a>)
<p></p>
<b>License:</b><br><a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>
<p></p>
<b>Authors:</b><br>Shin Fujishiro<p></p>

<dl><dt><div class="d_decl">template <a name="Id"></a><u>Id</u>(E)<br>template <a name="Id"></a><u>Id</u>(alias E)</div></dt>
<dd>Makes an alias of <span class="d_inlinecode">E</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>E</td>
<td valign=top>A compile-time entity: type, compile-time value, or any symbol.</td></tr>
</table><p></p>
<b>Example:</b><br>
Literal values can't be aliased directly.  Use <span class="d_inlinecode">meta.<a name="Id"></a><u>Id</u></span> as follows:
<pre class="d_code"><span class="d_keyword">template</span> Front(seq...)
{
    <span class="d_keyword">alias</span> meta.<span class="d_psymbol">Id</span>!(seq[0]) Front;
}
<span class="d_keyword">alias</span> Front!(10, 20, 30) front;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(front == 10);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="Seq"></a><u>Seq</u>(seq...)</div></dt>
<dd>Makes a sequence of compile-time entities.  The sequence is just an alias of
the template variadic arguments: <span class="d_inlinecode">seq</span>.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">Seq</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, string) Types;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Types[0] == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Types[1] == <span class="d_keyword">double</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Types[2] == string));
</pre>

 The sequence may contain compile-time expressions.  The following example
 makes a sequence of constant integers <span class="d_inlinecode">numbers</span> and embeds it into an
 array literal.
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">Seq</span>!(10, 20, 30) numbers;
<span class="d_keyword">int</span>[] arr = [ 0, numbers, 100 ];
<span class="d_keyword">assert</span>(arr == [ 0, 10, 20, 30, 100 ]);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="pack"></a><u>pack</u>(seq...)</div></dt>
<dd><span class="d_inlinecode">meta.<a name="pack"></a><u>pack</u></span> makes an atomic entity from a sequence, which is useful for
passing multiple sequences to a template.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>seq</td>
<td valign=top>Zero or more compile-time entities to pack.</td></tr>
</table><p></p>
<b>Example:</b><br>
The following code passes three separate sequences to <span class="d_inlinecode">meta.transverse</span>
 using <span class="d_inlinecode">meta.<a name="pack"></a><u>pack</u></span>:
<pre class="d_code"><span class="d_comment">// Query the 0-th element of each sequence.
</span><span class="d_keyword">alias</span> meta.transverse!(0, meta.<span class="d_psymbol">pack</span>!(<span class="d_keyword">int</span>, 32),
                          meta.<span class="d_psymbol">pack</span>!(<span class="d_keyword">double</span>, 5.0),
                          meta.<span class="d_psymbol">pack</span>!(string, <span class="d_string">"hello."</span>)) first;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(first[0] == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(first[1] == <span class="d_keyword">double</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(first[2] == string));
</pre>
<p></p>

<dl><dt><div class="d_decl">alias <a name="expand"></a><u>expand</u>;
</div></dt>
<dd>Returns the packed sequence: <span class="d_inlinecode">seq</span>.<p></p>

</dd>
<dt><div class="d_decl">size_t <a name="length"></a><u>length</u>;
</div></dt>
<dd>Returns the number of entities: <span class="d_inlinecode">seq.<a name="length"></a><u>length</u></span>.<p></p>

</dd>
<dt><div class="d_decl">template <a name="at"></a><u>at</u>(size_t i) if (i &lt; length)</div></dt>
<dd>Extracts the <span class="d_inlinecode">i</span>-th element of the packed sequence.<p></p>

</dd>
</dl>
</dd>
<dt><div class="d_decl">template <a name="isSame"></a><u>isSame</u>(A,B)<br>template <a name="isSame"></a><u>isSame</u>(A,alias B) if (!isType!(B))<br>template <a name="isSame"></a><u>isSame</u>(alias A,B) if (!isType!(A))<br>template <a name="isSame"></a><u>isSame</u>(alias A,alias B) if (!isType!(A) &amp;&amp; !isType!(B))</div></dt>
<dd>Determines if <span class="d_inlinecode">A</span> and <span class="d_inlinecode">B</span> are the same entities.
<p></p>
<span class="d_inlinecode">A</span> and <span class="d_inlinecode">B</span> are compared in terms of their mangled names.  So, a
literal value <span class="d_inlinecode">10</span> and a CTFE capable property function returning <span class="d_inlinecode">10</span>
are considered different; literals are values and properties are symbols.
<pre class="d_code"><span class="d_keyword">struct</span> S
{
    <span class="d_keyword">static</span> @property <span class="d_keyword">int</span> property() { <span class="d_keyword">return</span> 10; }
}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( meta.<span class="d_psymbol">isSame</span>!(10, 10));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!meta.<span class="d_psymbol">isSame</span>!(S.property, 10));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( meta.<span class="d_psymbol">isSame</span>!(S.property, S.property));
</pre>

<p></p>
<b>Returns:</b><br><span class="d_inlinecode"><b>true</b></span> if and only if <span class="d_inlinecode">A</span> and <span class="d_inlinecode">B</span> are the same entity.

<p></p>
<b>Example:</b><br>
Comparing various entities.
<pre class="d_code"><span class="d_comment">// Compare types.
</span><span class="d_keyword">struct</span> MyType {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( meta.<span class="d_psymbol">isSame</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!meta.<span class="d_psymbol">isSame</span>!(MyType, <span class="d_keyword">double</span>));

<span class="d_comment">// Compare values.  Type is significant.
</span><span class="d_keyword">enum</span> str = <span class="d_string">"abc"</span>;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( meta.<span class="d_psymbol">isSame</span>!(str, <span class="d_string">"abc"</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!meta.<span class="d_psymbol">isSame</span>!(10, 10u));      <span class="d_comment">// int and uint
</span>
<span class="d_comment">// Compare symbols.
</span><span class="d_keyword">void</span> fun() {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( meta.<span class="d_psymbol">isSame</span>!(fun, fun));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!meta.<span class="d_psymbol">isSame</span>!(fun, std));     <span class="d_comment">// function and package
</span></pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="isSame"></a><u>isSame</u>(A)<br>template <a name="isSame"></a><u>isSame</u>(alias A)</div></dt>
<dd>These overloads serve partial application of <span class="d_inlinecode">meta.<a name="isSame"></a><u>isSame</u></span>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Bind double as the first argument.
</span><span class="d_keyword">alias</span> meta.<span class="d_psymbol">isSame</span>!<span class="d_keyword">double</span> isDouble;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( isDouble!<span class="d_keyword">double</span>);    <span class="d_comment">// meta.isSame!(double, double)
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!isDouble!<span class="d_keyword">int</span>   );    <span class="d_comment">// meta.isSame!(double, int)
</span></pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="isType"></a><u>isType</u>(E)<br>template <a name="isType"></a><u>isType</u>(alias E)</div></dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if and only if <span class="d_inlinecode">E</span> is a type.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">int</span>, <span class="d_string">"x"</span>,
                <span class="d_keyword">double</span>, <span class="d_string">"y"</span>,
                string, <span class="d_string">"z"</span>) Mixed;

<span class="d_keyword">alias</span> meta.filter!(meta.<span class="d_psymbol">isType</span>, Mixed) Types;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Types == meta.Seq!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, string)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="isValue"></a><u>isValue</u>(E)<br>template <a name="isValue"></a><u>isValue</u>(alias E)</div></dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if and only if <span class="d_inlinecode">E</span> has a compile-time value.  Literals,
constants and CTFE-able property functions would pass the test.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">template</span> increment(<span class="d_keyword">alias</span> value) <span class="d_keyword">if</span> (meta.<span class="d_psymbol">isValue</span>!value)
{
    <span class="d_keyword">enum</span> increment = value + 1;
}
<span class="d_keyword">enum</span> a = increment!10;
<span class="d_keyword">enum</span> b = increment!increment;   <span class="d_comment">// Error: negates the constraint
</span></pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="isValue"></a><u>isValue</u>(T,E)<br>template <a name="isValue"></a><u>isValue</u>(T,alias E)</div></dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if and only if <span class="d_inlinecode">E</span> has a compile-time value implicitly
convertible to type <span class="d_inlinecode">T</span>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">template</span> increment(<span class="d_keyword">alias</span> value) <span class="d_keyword">if</span> (meta.<span class="d_psymbol">isValue</span>!(<span class="d_keyword">long</span>, value))
{
    <span class="d_keyword">enum</span> increment = value + 1;
}
<span class="d_keyword">enum</span> a = increment!10;
<span class="d_keyword">enum</span> b = increment!<span class="d_string">"me"</span>;    <span class="d_comment">// Error: nonconvertible to long
</span></pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="unaryT"></a><u>unaryT</u>(string expr)</div></dt>
<dd>Transforms a string representing a compile-time entity into a unary template
that returns the represented entity.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>expr</td>
<td valign=top>String representing a compile-time entity using a template parameter
        <span class="d_inlinecode">a</span> or <span class="d_inlinecode">A</span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Unary template that evaluates <span class="d_inlinecode">expr</span>.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">unaryT</span>!<span class="d_string">q{ const A }</span> Constify;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Constify!<span class="d_keyword">int</span> == <span class="d_keyword">const</span> <span class="d_keyword">int</span>));

<span class="d_keyword">alias</span> meta.<span class="d_psymbol">unaryT</span>!<span class="d_string">q{ a.length }</span> lengthof;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(lengthof!([ 1,2,3,4,5 ]) == 5);
</pre>

 The generated template can return a sequence.
<pre class="d_code"><span class="d_keyword">import</span> std.meta;
<span class="d_keyword">import</span> std.typecons;

<span class="d_comment">// Extracts the Types property of a Tuple instance.
</span><span class="d_keyword">alias</span> meta.<span class="d_psymbol">unaryT</span>!<span class="d_string">q{ A.Types }</span> expand;

<span class="d_keyword">alias</span> expand!(Tuple!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, string)) Types;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Types[0] == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Types[1] == <span class="d_keyword">double</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Types[2] == string));
</pre>

<p></p>
<b>See Also:</b><br><span class="d_inlinecode">meta.lambda</span><p></p>

</dd>
<dt><div class="d_decl">template <a name="binaryT"></a><u>binaryT</u>(string expr)</div></dt>
<dd>Transforms a string representing a compile-time entity into a binary template
that returns the represented entity.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>expr</td>
<td valign=top>String representing a compile-time entity using two template</td></tr>
</table><p></p>
<b>parameters:</b><br>
<span class="d_inlinecode">a, A</span> as the first one and <span class="d_inlinecode">b, B</span> the second.

<p></p>
<b>Returns:</b><br>Binary template that evaluates <span class="d_inlinecode">expr</span>.

<p></p>
<b>Example:</b><br>
This example uses the first parameter <span class="d_inlinecode">a</span> as a value and the second one
 <span class="d_inlinecode">B</span> as a type, and returns a value.
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">binaryT</span>!<span class="d_string">q{ a + B.sizeof }</span> accumSize;

<span class="d_keyword">enum</span> n1 = accumSize!( 0,    <span class="d_keyword">int</span>);
<span class="d_keyword">enum</span> n2 = accumSize!(n1, <span class="d_keyword">double</span>);
<span class="d_keyword">enum</span> n3 = accumSize!(n2,  <span class="d_keyword">short</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(n3 == 4 + 8 + 2);
</pre>

<p></p>
<b>See Also:</b><br><span class="d_inlinecode">meta.lambda</span><p></p>

</dd>
<dt><div class="d_decl">template <a name="variadicT"></a><u>variadicT</u>(string expr)</div></dt>
<dd>Transforms a string representing an expression into a variadic template.
The expression can read variadic arguments via <span class="d_inlinecode">args</span>.
<p></p>
The expression can also use named parameters as <span class="d_inlinecode">meta.unaryT</span>, but
the number of implicitly-named parameters is limited up to eight:
<span class="d_inlinecode">a, b, c, d, e, f, g</span> and <span class="d_inlinecode">h</span> (plus capitalized ones) depending
on the number of arguments.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>fun</td>
<td valign=top>Expression string or template declaration.  The string may use
       named parameters <span class="d_inlinecode">a</span> to <span class="d_inlinecode">h</span>, <span class="d_inlinecode">A</span> to <span class="d_inlinecode">H</span> and <span class="d_inlinecode">args</span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Variadic template that evaluates <span class="d_inlinecode">fun</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">variadicT</span>!<span class="d_string">q{ meta.Seq!(args[1 .. $], A) }</span> rotate1;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>([ rotate1!(1, 2, 3, 4) ] == [ 2, 3, 4, 1 ]);
</pre>

<p></p>
<b>See Also:</b><br><span class="d_inlinecode">meta.lambda</span><p></p>

</dd>
<dt><div class="d_decl">template <a name="lambda"></a><u>lambda</u>(string decl,captures...)</div></dt>
<dd>Transforms a string representing a template body into a variadic template.
<p></p>
<span class="d_inlinecode">meta.<a name="lambda"></a><u>lambda</u></span> is much like <span class="d_inlinecode">meta.variadicT</span> as it's variadic and
parameters can be accessed via <span class="d_inlinecode">args</span> and <span class="d_inlinecode">a</span>-<span class="d_inlinecode">h</span>.  In addition,
<span class="d_inlinecode">meta.<a name="lambda"></a><u>lambda</u></span> also supports recursions and local entity captures.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>decl</td>
<td valign=top>String representing a valid template body.  The body must
            declare a symbol <span class="d_inlinecode">_</span> that represents the result of the
            template.  The result can be overloaded if it's a function
            or a template.
<p></p>

            The body may use named parameters <span class="d_inlinecode">a</span> to <span class="d_inlinecode">h</span>, <span class="d_inlinecode">A</span> to
            <span class="d_inlinecode">H</span> and <span class="d_inlinecode">args</span>.  Also, named captures <span class="d_inlinecode">p</span> to <span class="d_inlinecode">w</span>,
            <span class="d_inlinecode">P</span> to <span class="d_inlinecode">W</span> and <span class="d_inlinecode">captures</span> are available.
<p></p>

            The body may use a symbol <span class="d_inlinecode"><a name="lambda"></a><u>lambda</u></span> that refers to the
            generated template itself.</td></tr>
<tr><td valign=top>captures</td>
<td valign=top>Local compile-time entities (types, values, templates etc.) to
            make available in the generated template.</td></tr>
</table><p></p>
<b>Returns:</b><br>Variadic template whose body is <span class="d_inlinecode">decl</span> and evaluates to <span class="d_inlinecode">_</span> declared
 in the body.

<p></p>
<b>Recursion:</b><br>
The generated template itself is accessible from the string using an
 identifier <span class="d_inlinecode"><a name="lambda"></a><u>lambda</u></span>, and you can define recursive templates:
<pre class="d_code"><span class="d_comment">// Remove pointer 'stars' from every type in a sequence.  The generated
</span><span class="d_comment">// template is passed to meta.map as a transoformer template.
</span><span class="d_keyword">alias</span> meta.map!(meta.<span class="d_psymbol">lambda</span>!(
                   <span class="d_string">q{
                        static if (is(A T == T*))
                        {
                            alias lambda!T _;   // recursion
                        }
                        else
                        {
                            alias        A _;
                        }
                    }</span>),
                <span class="d_keyword">int</span>*, <span class="d_keyword">void</span>**, <span class="d_keyword">short</span>, <span class="d_keyword">double</span>***) NoPointers;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(NoPointers[0] == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(NoPointers[1] == <span class="d_keyword">void</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(NoPointers[2] == <span class="d_keyword">short</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(NoPointers[3] == <span class="d_keyword">double</span>));
</pre>

<p></p>
<b>Captures:</b><br>
The template generated by <span class="d_inlinecode">meta.<a name="lambda"></a><u>lambda</u></span> can use local entities
 explicitly passed via the <span class="d_inlinecode">captures</span> parameter.  Like template
 parameters, captured entities get named <span class="d_inlinecode">p</span>-<span class="d_inlinecode">w</span> and <span class="d_inlinecode">P</span>-<span class="d_inlinecode">W</span>.
<pre class="d_code"><span class="d_keyword">struct</span> Example(T, UU...)
{
    <span class="d_comment">// Check if UU contains a type that implicitly convertible to T,
</span>    <span class="d_comment">// and issues an error if so.
</span>    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (meta.any!(meta.<span class="d_psymbol">lambda</span>!(
                            <span class="d_string">q{
                                 enum _ = is(A : P);
                             }</span>,
                             T),    <span class="d_comment">// T is captured as 'P'
</span>                         UU))
    {
        <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(0, <span class="d_string">"At least one type in "</span>~ UU.stringof ~<span class="d_string">" is "</span>
                        ~<span class="d_string">"implicitly convertible to "</span>~ T.stringof);
    }
}
Example!(<span class="d_keyword">int</span>, string, <span class="d_keyword">double</span>) Okay;
Example!(<span class="d_keyword">int</span>, string,   <span class="d_keyword">bool</span>) Error;    <span class="d_comment">// Convertible: bool -&gt; int
</span></pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="bind"></a><u>bind</u>(alias templat,args...)</div></dt>
<dd>Binds <span class="d_inlinecode">args</span> to the leftmost parameters of a template <span class="d_inlinecode">templat</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>templat</td>
<td valign=top>Template or string that can be tranformed to a variadic template
           using <span class="d_inlinecode">meta.variadicT</span>.</td></tr>
<tr><td valign=top>args</td>
<td valign=top>Zero or more template instantiation arguments to <a name="bind"></a><u>bind</u>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Template that instantiates <span class="d_inlinecode">templat</span> with the bound arguments and
 additional ones as <span class="d_inlinecode">templat!(args, ...)</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">template</span> compareSize(T, U)
{
    <span class="d_keyword">enum</span> compareSize = T.sizeof &lt; U.sizeof;
}

<span class="d_comment">// Get the types satisfying "int.sizeof &lt; U.sizeof".
</span><span class="d_keyword">alias</span> meta.filter!(meta.<span class="d_psymbol">bind</span>!(compareSize, <span class="d_keyword">int</span>),
                   <span class="d_keyword">byte</span>, <span class="d_keyword">double</span>, <span class="d_keyword">short</span>, <span class="d_keyword">int</span>, <span class="d_keyword">long</span>) Result;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Result == meta.Seq!(<span class="d_keyword">double</span>, <span class="d_keyword">long</span>) ));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="rbind"></a><u>rbind</u>(alias templat,args...)</div></dt>
<dd>Same as <span class="d_inlinecode">meta.bind</span> except that <span class="d_inlinecode">meta.<a name="rbind"></a><u>rbind</u></span> binds arguments to
rightmost parameters.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>templat</td>
<td valign=top>Template or string that can be tranformed to a variadic template
           using <span class="d_inlinecode">meta.variadicT</span>.</td></tr>
<tr><td valign=top>args</td>
<td valign=top>Zero or more template instantiation arguments to bind.</td></tr>
</table><p></p>
<b>Returns:</b><br>Template that instantiates <span class="d_inlinecode">templat</span> with the bound arguments and
 additional ones as <span class="d_inlinecode">templat!(..., args)</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">template</span> compareSize(T, U)
{
    <span class="d_keyword">enum</span> compareSize = T.sizeof &lt; U.sizeof;
}

<span class="d_comment">// Get the types satisfying "T.sizeof &lt; int.sizeof"
</span><span class="d_keyword">alias</span> meta.filter!(meta.<span class="d_psymbol">rbind</span>!(compareSize, <span class="d_keyword">int</span>),
                   <span class="d_keyword">byte</span>, <span class="d_keyword">double</span>, <span class="d_keyword">short</span>, <span class="d_keyword">int</span>, <span class="d_keyword">long</span>) Result;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Result == meta.Seq!(<span class="d_keyword">byte</span>, <span class="d_keyword">short</span>) ));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="delay"></a><u>delay</u>(alias templat,args...)</div></dt>
<dd>Binds <span class="d_inlinecode">args</span> to all the parameters of <span class="d_inlinecode">templat</span>.  Generated template
will instantiate <span class="d_inlinecode">templat</span> with just the bound arguments.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>templat</td>
<td valign=top>Template or string to instantiate.</td></tr>
<tr><td valign=top>args</td>
<td valign=top>Complete arguments for <span class="d_inlinecode">templat</span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Variadic template that constantly returns <span class="d_inlinecode">templat!args</span> regardless of
 its arguments.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">delay</span>!(meta.Id, <span class="d_keyword">int</span>) Int;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Int!() == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Int!(<span class="d_keyword">void</span>) == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Int!(1,2,3) == <span class="d_keyword">int</span>));
</pre>

 Using a delayed template for a fallback case of <span class="d_inlinecode">meta.guard</span>:
<pre class="d_code"><span class="d_keyword">struct</span> Error;

<span class="d_keyword">alias</span> meta.guard!(<span class="d_string">q{ A[] }</span>, meta.<span class="d_psymbol">delay</span>!(meta.Id, Error)) Array;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Array!<span class="d_keyword">int</span> == <span class="d_keyword">int</span>[]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Array!100 == Error));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="constant"></a><u>constant</u>(E)<br>template <a name="constant"></a><u>constant</u>(alias E)<br>template <a name="constant"></a><u>constant</u>()</div></dt>
<dd>Generates a template that constantly evaluates to <span class="d_inlinecode">E</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>E</td>
<td valign=top>Compile-time entity to hold.</td></tr>
</table><p></p>
<b>Returns:</b><br>Variadic template that ignores its arguments and just returns <span class="d_inlinecode">E</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">constant</span>!<span class="d_keyword">int</span> Int;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Int!() == <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Int!(<span class="d_keyword">double</span>, string) == <span class="d_keyword">int</span>));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="not"></a><u>not</u>(alias pred)<br>template <a name="not"></a><u>not</u>(string pred)</div></dt>
<dd>Creates a predicate template that inverts the result of the given one.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Predicate template or expression string to invert.  The result
        must be a compile-time value that is implicitly convertible to
        <span class="d_inlinecode">bool</span> in conditional expressions.</td></tr>
</table><p></p>
<b>Returns:</b><br>Template that evaluates <span class="d_inlinecode">pred</span> and returns an inverted result.

<p></p>
<b>Example:</b><br>
Passing an inverted predicate to the <span class="d_inlinecode">meta.countIf</span>.
<pre class="d_code"><span class="d_keyword">template</span> isStruct(T)
{
    <span class="d_keyword">enum</span> isStruct = <span class="d_keyword">is</span>(T == <span class="d_keyword">struct</span>) || <span class="d_keyword">is</span>(T == <span class="d_keyword">union</span>);
}

<span class="d_keyword">struct</span> S {}
<span class="d_keyword">union</span>  U {}
<span class="d_keyword">class</span>  C {}

<span class="d_comment">// Count non-struct types in the sequence.
</span><span class="d_keyword">enum</span> n = meta.countIf!(meta.<span class="d_psymbol">not</span>!isStruct,
                       <span class="d_keyword">int</span>, <span class="d_keyword">double</span>, S, U, C);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(n == 3);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="and"></a><u>and</u>(preds...)</div></dt>
<dd>Composes predicate templates with the logical <span class="d_inlinecode">&amp;&amp;</span> operator.
<p></p>
The predicates will be evaluated in the same order as passed to this
template.  The evaluations are lazy; if one of the predicates is not
satisfied, <span class="d_inlinecode">meta.<a name="and"></a><u>and</u></span> immediately returns <span class="d_inlinecode"><b>false</b></span> without evaluating
remaining predicates.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>preds</td>
<td valign=top>Zero or more predicate templates to compose.  This argument can be
         empty; in that case, the resulting template constantly evaluates to
         <span class="d_inlinecode"><b>true</b></span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Composition predicate template that tests if its arguments satisfy all the
 predicates <span class="d_inlinecode">preds</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">and</span>!(meta.isType, <span class="d_string">q{ is(A : long) }</span>, <span class="d_string">q{ A.min &lt; 0 }</span>) isSignedInt;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( isSignedInt!<span class="d_keyword">short</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( isSignedInt!<span class="d_keyword">int</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!isSignedInt!<span class="d_keyword">uint</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!isSignedInt!string);     <span class="d_comment">// stops at the second predicate
</span><span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!isSignedInt!<span class="d_string">"wrong"</span>);    <span class="d_comment">// stops at the first predicate
</span></pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="or"></a><u>or</u>(preds...)</div></dt>
<dd>Composes predicate templates with the logical <span class="d_inlinecode">||</span> operator.
<p></p>
The predicates will be evaluated in the same order as passed to this
template.  The evaluations are lazy; if one of the predicates is
satisfied, <span class="d_inlinecode">meta.<a name="or"></a><u>or</u></span> immediately returns <span class="d_inlinecode"><b>true</b></span> without evaluating
remaining predicates.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>preds</td>
<td valign=top>Zero <a name="or"></a><u>or</u> more predicate templates to compose.  This argument can be
         empty; in that case, the resulting template constantly evaluates to
         <span class="d_inlinecode"><b>false</b></span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Composition predicate template that tests if its arguments satisfy at least
 one of the predicates <span class="d_inlinecode">preds</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Note that bool doesn't have the .min property.
</span><span class="d_keyword">alias</span> meta.filter!(meta.<span class="d_psymbol">or</span>!(<span class="d_string">q{ A.sizeof &lt; 4 }</span>, <span class="d_string">q{ A.min &lt; 0 }</span>),
                   <span class="d_keyword">bool</span>, <span class="d_keyword">ushort</span>, <span class="d_keyword">int</span>, <span class="d_keyword">uint</span>) R;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(R == meta.Seq!(<span class="d_keyword">bool</span>, <span class="d_keyword">ushort</span>, <span class="d_keyword">int</span>)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="compose"></a><u>compose</u>(templates...)</div></dt>
<dd><span class="d_inlinecode">meta.<a name="compose"></a><u>compose</u>!(t1, t2, ..., tn)</span> returns a variadic template that in
turn instantiates the passed in templates in a chaining way:
<pre class="d_code"><span class="d_keyword">template</span> composition(args...)
{
    <span class="d_keyword">alias</span> t1!(t2!( ... tn!(args) ... )) composition;
}
</pre>
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>templates</td>
<td valign=top>One or more templates making up the chain.  Each template
             can be a template or a string; strings are transformed to
             varadic templates using <span class="d_inlinecode">meta.variadicT</span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>New template that instantiates the chain of <span class="d_inlinecode">templates</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">compose</span>!(<span class="d_string">q{ A[] }</span>,
                    <span class="d_string">q{ const A }</span>) ConstArray;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(ConstArray!<span class="d_keyword">int</span> == <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[]));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="guard"></a><u>guard</u>(templates...) if (templates.length &gt; 0)</div></dt>
<dd>Generates a template that tries instantiating specified templates in turn
and returns the result of the first compilable template.
<p></p>
For example, <span class="d_inlinecode">meta.<a name="guard"></a><u>guard</u>!(t1, t2)</span> generates a template that behaves
as follows:
<pre class="d_code"><span class="d_keyword">template</span> trial(args...)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (<span class="d_keyword">__traits</span>(compiles, t1!(args)))
    {
        <span class="d_keyword">alias</span> t1!(args) trial;
    }
    <span class="d_keyword">else</span>
    {
        <span class="d_keyword">alias</span> t2!(args) trial;
    }
}
</pre>

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>templates</td>
<td valign=top>Templates to try instantiation.  Each template can be a real
             template or a string that can be transformed to a template
             using <span class="d_inlinecode">meta.variadicT</span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Variadic template that instantiates the first compilable template among
 <span class="d_inlinecode">templates</span>.  The last template is not guarded; if all the templates
 failed, the generated template will fail due to the last one.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">guard</span>!(<span class="d_string">q{ A.min &lt; 0 }</span>, <span class="d_string">q{ false }</span>) hasNegativeMin;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( hasNegativeMin!<span class="d_keyword">int</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!hasNegativeMin!<span class="d_keyword">uint</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!hasNegativeMin!<span class="d_keyword">void</span>);    <span class="d_comment">// void.min is not defined!
</span></pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="conditional"></a><u>conditional</u>(alias pred,alias then,alias otherwise = meta.Id)</div></dt>
<dd>Generates a template that conditionally instantiates either <span class="d_inlinecode">then</span> or
<span class="d_inlinecode">otherwise</span> depending on the result of <span class="d_inlinecode">pred</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Predicate template.</td></tr>
<tr><td valign=top>then</td>
<td valign=top>Template to instantiate when <span class="d_inlinecode">pred</span> is satisfied.</td></tr>
<tr><td valign=top>otherwise</td>
<td valign=top>Template to instantiate when <span class="d_inlinecode">pred</span> is not satisfied.</td></tr>
</table><p></p>
<b>Returns:</b><br>Variadic template that instantiates <span class="d_inlinecode">then</span> with its arguments if the
 arguments satisfy <span class="d_inlinecode">pred</span>, or instantiates <span class="d_inlinecode">otherwise</span> with the same
 arguments if not.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">import</span> std.meta, std.traits, std.typecons;

<span class="d_keyword">alias</span> meta.<span class="d_psymbol">conditional</span>!(<span class="d_string">q{ is(A == class) }</span>, Rebindable, Unqual) NoTopConst;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>( NoTopConst!(<span class="d_keyword">const</span> Object) == Rebindable!(<span class="d_keyword">const</span> Object) ));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>( NoTopConst!(<span class="d_keyword">const</span> <span class="d_keyword">int</span>[]) == <span class="d_keyword">const</span>(<span class="d_keyword">int</span>)[] ));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>( NoTopConst!(<span class="d_keyword">const</span> <span class="d_keyword">int</span>) == <span class="d_keyword">int</span> ));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="apply"></a><u>apply</u>(alias templat,args...)<br>template <a name="apply"></a><u>apply</u>(string templat,args...)</div></dt>
<dd>Instantiates <span class="d_inlinecode">templat</span> with the specified arguments.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>templat</td>
<td valign=top>Template to instantiate.  The argument can be a pure template or
           a string that can be transformed into a pure template using
           <span class="d_inlinecode">meta.variadicT</span>.</td></tr>
<tr><td valign=top>args</td>
<td valign=top>The instantiation arguments to pass to <span class="d_inlinecode">templat</span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>The result: <span class="d_inlinecode">templat!args</span>.

<p></p>
<b>Example:</b><br>
Due to a syntactical limitation of the language, templates generated by
 higher-order templates (such as <span class="d_inlinecode">meta.guard</span>) can't be instantiated
 directly.  Use <span class="d_inlinecode">meta.<a name="apply"></a><u>apply</u></span> to instantiate such kind of temporary templates.
<pre class="d_code"><span class="d_keyword">template</span> Example(Arg)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (meta.<span class="d_psymbol">apply</span>!(meta.guard!(<span class="d_string">q{ A.min &lt; 0 }</span>,
                                       <span class="d_string">q{     false }</span>), Arg))
    {
        <span class="d_comment">// ...
</span>    }
}
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="expand"></a><u>expand</u>(alias arr)</div></dt>
<dd>Expands a compile-time array into a sequence of the elements.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>arr</td>
<td valign=top>Compile-time expression of an array.  The array can be dynamic or
       static.  The length and elements must be known at compile-time.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of the elements of <span class="d_inlinecode">arr</span>.

<p></p>
<b>Example:</b><br>
Using <span class="d_inlinecode">meta.<a name="expand"></a><u>expand</u></span> to apply a meta algorithm <span class="d_inlinecode">meta.map</span> on
 elements of a compile-time array.
<pre class="d_code"><span class="d_keyword">enum</span> functions = [ <span class="d_string">"fun"</span>, <span class="d_string">"gun"</span>, <span class="d_string">"hun"</span> ];

<span class="d_comment">// Use meta.map to transform the function names into signatures with
</span><span class="d_comment">// help of meta.expand.
</span><span class="d_keyword">alias</span> meta.map!(meta.lambda!(
                   <span class="d_string">q{
                        // Make a signature of a variadic function of
                        // the given name 'a'.
                        enum _ = "auto "~ a ~"(Args...)(Args args)";
                    }</span>),
                meta.<span class="d_psymbol">expand</span>!functions) signatures;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(signatures[0] == <span class="d_string">"auto fun(Args...)(Args args)"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(signatures[1] == <span class="d_string">"auto gun(Args...)(Args args)"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(signatures[2] == <span class="d_string">"auto hun(Args...)(Args args)"</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="iota"></a><u>iota</u>(alias beg,alias end,alias step) if (step &lt;&gt; 0)<br>template <a name="iota"></a><u>iota</u>(alias beg,alias end)<br>template <a name="iota"></a><u>iota</u>(alias end)</div></dt>
<dd>Yields a sequence of numbers starting from <span class="d_inlinecode">beg</span> to <span class="d_inlinecode">end</span> with the
specified <span class="d_inlinecode">step</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>beg</td>
<td valign=top>Compile-time numeral value (<span class="d_inlinecode">0</span> if not specified).  The generated
        sequence starts with <span class="d_inlinecode">beg</span> if not empty.</td></tr>
<tr><td valign=top>end</td>
<td valign=top>Compile-time numeral value.  The resulting sequence stops before
        <span class="d_inlinecode">end</span> and never contain this value.</td></tr>
<tr><td valign=top>step</td>
<td valign=top>Compile-time numeral value (<span class="d_inlinecode">1</span> if not specified).  The generated
        sequence increases or decreases by <span class="d_inlinecode">step</span>.  This value may not
        be zero or NaN.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of compile-time numbers starting from <span class="d_inlinecode">beg</span> to <span class="d_inlinecode">end</span>,
 increasing/decreasing by <span class="d_inlinecode">step</span>.  The generated sequence is empty if
 <span class="d_inlinecode">beg</span> is ahead of <span class="d_inlinecode">end</span> in terms of the <span class="d_inlinecode">step</span>'s direction.

<p></p>
<b>Examples:</b><br>Filling array elements using <span class="d_inlinecode">meta.<a name="iota"></a><u>iota</u></span>:
<pre class="d_code"><span class="d_keyword">static</span> Base64Chars = <span class="d_keyword">cast</span>(<span class="d_keyword">immutable</span> <span class="d_keyword">char</span>[64])
    [
        meta.<span class="d_psymbol">iota</span>!('A', 'Z'+1),
        meta.<span class="d_psymbol">iota</span>!('a', 'z'+1),
        meta.<span class="d_psymbol">iota</span>!('0', '9'+1), '+', '/'
    ];
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(Base64Chars[16] == 'Q');
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(Base64Chars[32] == 'g');
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(Base64Chars[62] == '+');
</pre>

 So-called static foreach:
<pre class="d_code"><span class="d_keyword">void</span> shift(Args...)(<span class="d_keyword">ref</span> Args args)
{
    <span class="d_keyword">foreach</span> (i; meta.<span class="d_psymbol">iota</span>!(1, +args.length))
    {
        args[i - 1] = args[i];
    }
    args[$ - 1] = args[$ - 1].init;
}

<span class="d_keyword">double</span> a;
<span class="d_keyword">int</span>    b = 10;
<span class="d_keyword">ushort</span> c = 20;

shift(a, b, c);
<span class="d_keyword">assert</span>(a == 10);
<span class="d_keyword">assert</span>(b == 20);
<span class="d_keyword">assert</span>(c ==  0);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="recur"></a><u>recur</u>(size_t n,alias fun,Seed...)</div></dt>
<dd>Generates a sequence by repeatedly applying <span class="d_inlinecode">fun</span> on generated elements,
and takes the first <span class="d_inlinecode">n</span> results:
<pre class="d_code">meta.<span class="d_psymbol">recur</span>!(n, fun, Seed) = (Seed, fun!Seed, fun!(fun!Seed), ...)
</pre>
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>n</td>
<td valign=top>Number of recurrences.  Specify zero to get the empty sequence.</td></tr>
<tr><td valign=top>fun</td>
<td valign=top>Recurrence template that computes the next state.  The state can be
        any sequence which can be passed to <span class="d_inlinecode">fun</span> itself.</td></tr>
<tr><td valign=top>Seed</td>
<td valign=top>Initial state.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence composed of <span class="d_inlinecode">Seed</span> followed by <span class="d_inlinecode">fun!Seed</span>, <span class="d_inlinecode">fun!(fun!Seed)</span>,
 ... etc., ending with the <span class="d_inlinecode">n-1</span> repeated application of <span class="d_inlinecode">fun</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">recur</span>!(4, <span class="d_string">q{ A* }</span>, <span class="d_keyword">int</span>) Pointers;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Pointers == meta.Seq!(<span class="d_keyword">int</span>, <span class="d_keyword">int</span>*, <span class="d_keyword">int</span>**, <span class="d_keyword">int</span>***)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="repeat"></a><u>repeat</u>(size_t n,seq...)</div></dt>
<dd>Creates a sequence in which <span class="d_inlinecode">seq</span> repeats <span class="d_inlinecode">n</span> times.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>n</td>
<td valign=top>The number of repetition.  May be zero.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to repeat.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence composed of <span class="d_inlinecode">n</span> <span class="d_inlinecode">seq</span>s.  The empty sequence is returned
 if <span class="d_inlinecode">n</span> is zero or <span class="d_inlinecode">seq</span> is empty.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">static</span> <span class="d_keyword">immutable</span> array =
    [
        meta.<span class="d_psymbol">repeat</span>!(3, 1,2,3),
        meta.<span class="d_psymbol">repeat</span>!(3, 4,5,6),
    ];
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(array == [ 1,2,3, 1,2,3, 1,2,3,
                         4,5,6, 4,5,6, 4,5,6 ]);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="swapAt"></a><u>swapAt</u>(size_t i,size_t j,seq...)</div></dt>
<dd>Swaps <span class="d_inlinecode">i</span>-th and <span class="d_inlinecode">j</span>-th elements of <span class="d_inlinecode">seq</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>i</td>
<td valign=top>Valid index for <span class="d_inlinecode">seq</span>.</td></tr>
<tr><td valign=top>j</td>
<td valign=top>ditto.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Target sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br><span class="d_inlinecode">seq</span> in which <span class="d_inlinecode">seq[i]</span> and <span class="d_inlinecode">seq[j]</span> are replaced with each other.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">byte</span>, <span class="d_keyword">short</span>, <span class="d_keyword">int</span>, <span class="d_keyword">long</span>) Types;

<span class="d_comment">// Swap short and int.
</span><span class="d_keyword">alias</span> meta.<span class="d_psymbol">swapAt</span>!(1, 2, Types) Swapped;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Swapped == meta.Seq!(<span class="d_keyword">byte</span>, <span class="d_keyword">int</span>, <span class="d_keyword">short</span>, <span class="d_keyword">long</span>)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="extract"></a><u>extract</u>(alias indices,seq...)</div></dt>
<dd>Extracts elements at the specified positions out of <span class="d_inlinecode">seq</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>indices</td>
<td valign=top>Compile-time array of indices designating elements to extract.
           Each index must be less than <span class="d_inlinecode">seq.length</span> and implicitly
           convertible to <span class="d_inlinecode">size_t</span>.  Duplicate indices are allowed.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Source sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of elements extracted from <span class="d_inlinecode">seq</span>.  The order of the elements
 is the same as that of corresponding indices in <span class="d_inlinecode">indices</span>.  The length
 of the result is the same as that of <span class="d_inlinecode">indices</span>, and the empty sequence
 is returned if <span class="d_inlinecode">indices</span> is empty.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">double</span>, <span class="d_string">"value"</span>, 5.0) seq;
<span class="d_keyword">alias</span> meta.<span class="d_psymbol">extract</span>!([ 0, 2 ], seq) extracted;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(extracted.length == 2);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(extracted[0] == <span class="d_keyword">double</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(   extracted[1] == 5.0    );
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="reverse"></a><u>reverse</u>(seq...)</div></dt>
<dd>Reverses the sequence <span class="d_inlinecode">seq</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>seq</td>
<td valign=top>Sequence to reverse.</td></tr>
</table><p></p>
<b>Returns:</b><br><span class="d_inlinecode">seq</span> in the reverse order.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">reverse</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, string) Rev;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Rev == meta.Seq!(string, <span class="d_keyword">double</span>, <span class="d_keyword">int</span>)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="rotate"></a><u>rotate</u>(sizediff_t n,seq...)</div></dt>
<dd>Rotates <span class="d_inlinecode">seq</span> by <span class="d_inlinecode">n</span>.  If <span class="d_inlinecode">n</span> is positive and less than <span class="d_inlinecode">seq</span>,
the result is <span class="d_inlinecode">(seq[n .. $], seq[0 .. n])</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>n</td>
<td valign=top>The amount of rotation.  The sign determines the direction:
       positive for left rotation and negative for right rotation.
       This argument can be zero or larger than <span class="d_inlinecode">seq.length</span>.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to rotate.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence <span class="d_inlinecode">seq</span> rotated by <span class="d_inlinecode">n</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">rotate</span>!(+1, <span class="d_keyword">int</span>, <span class="d_keyword">double</span>, string) rotL;
<span class="d_keyword">alias</span> meta.<span class="d_psymbol">rotate</span>!(-1, <span class="d_keyword">int</span>, <span class="d_keyword">double</span>, string) rotR;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(meta.tag!rotL == meta.tag!(<span class="d_keyword">double</span>, string, <span class="d_keyword">int</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(meta.tag!rotR == meta.tag!(string, <span class="d_keyword">int</span>, <span class="d_keyword">double</span>));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="stride"></a><u>stride</u>(size_t n,seq...) if (n &gt;= 1)</div></dt>
<dd>Gets the elements of sequence with stride <span class="d_inlinecode">n</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>n</td>
<td valign=top>Stride width.  <span class="d_inlinecode">n</span> must not be zero.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to stride.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of <span class="d_inlinecode">0,n,2n,...</span>-th elements of the given sequence:
 <span class="d_inlinecode">(seq[0], seq[n], seq[2*n], ...)</span>.  The empty sequence is returned if the
 given sequence <span class="d_inlinecode">seq</span> is empty.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">int</span>, <span class="d_string">"index"</span>, 10,
                <span class="d_keyword">double</span>, <span class="d_string">"number"</span>, 5.0) seq;
<span class="d_keyword">alias</span> meta.<span class="d_psymbol">stride</span>!(3, seq        ) Types;
<span class="d_keyword">alias</span> meta.<span class="d_psymbol">stride</span>!(3, seq[1 .. $]) names;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(meta.tag!Types == meta.tag!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(meta.tag!names == meta.tag!(<span class="d_string">"index"</span>, <span class="d_string">"number"</span>));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="segment"></a><u>segment</u>(size_t n,seq...) if (n &gt;= 1)</div></dt>
<dd>Splits sequence <span class="d_inlinecode">seq</span> into segments of the same length <span class="d_inlinecode">n</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>n</td>
<td valign=top>The size of each segment.  <span class="d_inlinecode">n</span> must not be zero.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to split.  The sequence can have arbitrary length.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of packed segments of length <span class="d_inlinecode">n</span>.  Each <a name="segment"></a><u>segment</u> is packed using
 <span class="d_inlinecode">meta.pack</span>; use the <span class="d_inlinecode">expand</span> property to yield the contents.
<p></p>

 The last segment can be shorter than <span class="d_inlinecode">n</span> if <span class="d_inlinecode">seq.length</span> is not an
 exact multiple of <span class="d_inlinecode">n</span>.  The empty sequence is returned if <span class="d_inlinecode">seq</span> is
 empty.

<p></p>
<b>Example:</b><br>
<span class="d_inlinecode">meta.<a name="segment"></a><u>segment</u></span> would be useful to scan simple patterns out of
 template parameters or other sequences.
<pre class="d_code"><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">int</span>, <span class="d_string">"index"</span>, 10,
                <span class="d_keyword">double</span>, <span class="d_string">"number"</span>, 5.0) seq;

<span class="d_keyword">alias</span> meta.<span class="d_psymbol">segment</span>!(3, seq) patterns;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(meta.isSame!(patterns[0], meta.pack!(<span class="d_keyword">int</span>, <span class="d_string">"index"</span>, 10)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(meta.isSame!(patterns[1], meta.pack!(<span class="d_keyword">double</span>, <span class="d_string">"number"</span>, 5.0)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="segmentWith"></a><u>segmentWith</u>(alias fun,size_t n,seq...) if (n == 1)<br>template <a name="segmentWith"></a><u>segmentWith</u>(alias fun,size_t n,seq...) if (n &gt; 1)</div></dt>
<dd>Generalization of <span class="d_inlinecode">meta.segment</span> passing each segment to <span class="d_inlinecode">fun</span> instead
of <span class="d_inlinecode">meta.pack</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>fun</td>
<td valign=top><span class="d_inlinecode">n</span>-ary template that transforms each segment.</td></tr>
<tr><td valign=top>n</td>
<td valign=top>The size of each segment.  <span class="d_inlinecode">n</span> must not be zero.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to process.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of the results of <span class="d_inlinecode">fun</span> applied to each segment.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">segmentWith</span>!(<span class="d_string">q{ B[A] }</span>, 2,
                        string, <span class="d_keyword">int</span>, string, <span class="d_keyword">double</span>) result;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(result[0] ==    <span class="d_keyword">int</span>[string]));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(result[1] == <span class="d_keyword">double</span>[string]));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="transverse"></a><u>transverse</u>(size_t i,seqs...) if (isTransversable!(i,seqs))</div></dt>
<dd>Given sequence of packed sequences, generates a sequence transversing
the <span class="d_inlinecode">i</span>-th element of each of the sequences.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>i</td>
<td valign=top>Valid index for each packed sequence in <span class="d_inlinecode">seqs</span>.</td></tr>
<tr><td valign=top>seqs</td>
<td valign=top>Sequence of packed sequences.  Each packed sequence must have a
        property <span class="d_inlinecode">expand</span> that yields a sequence and its length must be
        greater than <span class="d_inlinecode">i</span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence composed of the <span class="d_inlinecode">i</span>-th element of each of the given sequences.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">transverse</span>!(1, meta.pack!(<span class="d_keyword">int</span>, 255),
                          meta.pack!(<span class="d_keyword">double</span>, 7.5),
                          meta.pack!(string, <span class="d_string">"yo"</span>)) second;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(meta.tag!second == meta.tag!(255, 7.5, <span class="d_string">"yo"</span>));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="zip"></a><u>zip</u>(seqs...) if (isZippable!(seqs))</div></dt>
<dd>Generates a sequence iterating given sequences in lockstep.  The iteration
stops on encountering the end of the shortest sequence.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>seqs</td>
<td valign=top>Sequence of packed sequences.  Each packed sequence must have a
        property <span class="d_inlinecode">expand</span> that yields a sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of the transversals of <span class="d_inlinecode">seqs</span>, each of which is the result of
 <span class="d_inlinecode">meta.transversal</span> packed in a <span class="d_inlinecode">meta.pack</span>.  The empty sequence is
 returned if <span class="d_inlinecode">seqs</span> is empty or any of the sequences is empty.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">zip</span>!(meta.pack!(<span class="d_keyword">int</span>, 255),
                meta.pack!(<span class="d_keyword">double</span>, 7.5),
                meta.pack!(string, <span class="d_string">"yo"</span>)) zipped;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(meta.isSame!(zipped[0], meta.pack!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, string)));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(meta.isSame!(zipped[1], meta.pack!(255, 7.5, <span class="d_string">"yo"</span>)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="zipWith"></a><u>zipWith</u>(alias fun,seqs...) if (isZippable!(seqs))</div></dt>
<dd>Generalization of <span class="d_inlinecode">meta.zip</span> passing each transversal to <span class="d_inlinecode">fun</span>, instead
of packing with <span class="d_inlinecode">meta.pack</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>fun</td>
<td valign=top>Template of arity <span class="d_inlinecode">seqs.length</span> that transforms each transversal.</td></tr>
<tr><td valign=top>seqs</td>
<td valign=top>Sequence of packed sequences.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of the results of <span class="d_inlinecode">fun</span> applied to each transversal of <span class="d_inlinecode">seqs</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.pack!(<span class="d_string">"int"</span>, <span class="d_string">"double"</span>, <span class="d_string">"string"</span>) types;
<span class="d_keyword">alias</span> meta.pack!(  <span class="d_string">"i"</span>,      <span class="d_string">"x"</span>,      <span class="d_string">"s"</span>) names;
<span class="d_keyword">alias</span> meta.<span class="d_psymbol">zipWith</span>!(<span class="d_string">q{ a~" "~b }</span>, types, names) zipped;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(zipped[0] == <span class="d_string">"int i"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(zipped[1] == <span class="d_string">"double x"</span>);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(zipped[2] == <span class="d_string">"string s"</span>);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="map"></a><u>map</u>(alias fun,seq...)<br>template <a name="map"></a><u>map</u>(string fun,seq...)</div></dt>
<dd>Transforms a sequence <span class="d_inlinecode">seq</span> into <span class="d_inlinecode">(fun!(seq[0]), fun!(seq[1]), ...)</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>fun</td>
<td valign=top>Unary template used to transform each element of <span class="d_inlinecode">seq</span> into another
       compile-time entity.  The result can be a sequence.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence of compile-time entities to transform.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of the results of <span class="d_inlinecode">fun</span> applied to each element of <span class="d_inlinecode">seq</span> in
 turn.

<p></p>
<b>Examples:</b><br>Map types into pointers.
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">map</span>!(<span class="d_string">q{ A* }</span>, <span class="d_keyword">int</span>, <span class="d_keyword">double</span>, <span class="d_keyword">void</span>*) PP;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(PP[0] ==    <span class="d_keyword">int</span>*));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(PP[1] == <span class="d_keyword">double</span>*));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(PP[2] ==  <span class="d_keyword">void</span>**));
</pre>

 Doubling elements:
<pre class="d_code"><span class="d_keyword">static</span> <span class="d_keyword">assert</span>([ meta.<span class="d_psymbol">map</span>!(<span class="d_string">q{ meta.Seq!(a, a) }</span>, 1,2,3) ] == [ 1,1, 2,2, 3,3 ]);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="filter"></a><u>filter</u>(alias pred,seq...)</div></dt>
<dd>Creates a sequence only containing elements of <span class="d_inlinecode">seq</span> satisfying <span class="d_inlinecode">pred</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Unary predicate template that decides whether or not to include an
        element in the resulting sequence.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to filter.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence only containing elements of <span class="d_inlinecode">seq</span> for each of which <span class="d_inlinecode">pred</span>
 evaluates to <span class="d_inlinecode"><b>true</b></span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">filter</span>!(<span class="d_string">q{ A.sizeof &lt; 4 }</span>, <span class="d_keyword">byte</span>, <span class="d_keyword">short</span>, <span class="d_keyword">int</span>, <span class="d_keyword">long</span>) SmallTypes;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(SmallTypes == meta.Seq!(<span class="d_keyword">byte</span>, <span class="d_keyword">short</span>)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="remove"></a><u>remove</u>(E,seq...)<br>template <a name="remove"></a><u>remove</u>(alias E,seq...)</div></dt>
<dd>Removes all occurrences of <span class="d_inlinecode">E</span> in <span class="d_inlinecode">seq</span> if any.  Each occurrence is
tested in terms of <span class="d_inlinecode">meta.isSame</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>E</td>
<td valign=top>Compile-time entity to remove.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Target sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence <span class="d_inlinecode">seq</span> in which any occurrence of <span class="d_inlinecode">E</span> is erased.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">remove</span>!(<span class="d_keyword">void</span>, <span class="d_keyword">int</span>, <span class="d_keyword">void</span>, <span class="d_keyword">double</span>, <span class="d_keyword">void</span>, string) Res;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Res == meta.Seq!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, string)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="replace"></a><u>replace</u>(From,To,seq...)<br>template <a name="replace"></a><u>replace</u>(alias From,To,seq...) if (!isType!(From))<br>template <a name="replace"></a><u>replace</u>(From,alias To,seq...) if (!isType!(To))<br>template <a name="replace"></a><u>replace</u>(alias From,alias To,seq...) if (!isType!(From) &amp;&amp; !isType!(To))</div></dt>
<dd>Replaces all occurrences of <span class="d_inlinecode">From</span> in <span class="d_inlinecode">seq</span> with <span class="d_inlinecode">To</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>From</td>
<td valign=top>Element to remove.</td></tr>
<tr><td valign=top>To</td>
<td valign=top>Element to insert in place of <span class="d_inlinecode">From</span>.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to perform replacements.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence <span class="d_inlinecode">seq</span> in which every occurrence of <span class="d_inlinecode">From</span> (if any) is
 replaced by <span class="d_inlinecode">To</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">struct</span> This;

<span class="d_keyword">struct</span> Example(Params...)
{
    <span class="d_comment">// Resolve 'This'
</span>    <span class="d_keyword">alias</span> meta.<span class="d_psymbol">replace</span>!(This, Example!Params, Params) Types;
}
<span class="d_keyword">alias</span> Example!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, This) Ex;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Ex.Types[2] == Ex));
</pre>

<p></p>
<b>Tips:</b><br>
You may want to use <span class="d_inlinecode">meta.map</span> with <span class="d_inlinecode">meta.conditional</span> to perform more
 complex replacements.  The following example replaces every const types in a
 type sequence with a <span class="d_inlinecode">void</span>.
<pre class="d_code"><span class="d_keyword">alias</span> meta.map!(meta.conditional!(<span class="d_string">q{ is(A == const) }</span>, meta.constant!<span class="d_keyword">void</span>),
                <span class="d_keyword">int</span>, <span class="d_keyword">const</span> <span class="d_keyword">double</span>, string, <span class="d_keyword">const</span> <span class="d_keyword">bool</span>) Res;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Res == meta.Seq!(<span class="d_keyword">int</span>, <span class="d_keyword">void</span>, string, <span class="d_keyword">void</span>)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="sort"></a><u>sort</u>(alias comp,seq...)</div></dt>
<dd>Sorts a sequence according to comparison predicate <span class="d_inlinecode">comp</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>comp</td>
<td valign=top>Binary comparison predicate that compares elements of <span class="d_inlinecode">seq</span>.
        It typically works as the <span class="d_inlinecode">&lt;</span> operator to arrange the result in
        ascending order.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to sort.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence <span class="d_inlinecode">seq</span> sorted according to the predicate <span class="d_inlinecode">comp</span>.  The relative
 order of equivalent elements will be preserved (i.e. stable).

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Sort types in terms of the sizes.
</span><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">double</span>, <span class="d_keyword">int</span>, <span class="d_keyword">bool</span>, <span class="d_keyword">uint</span>, <span class="d_keyword">short</span>) Types;

<span class="d_keyword">alias</span> meta.<span class="d_psymbol">sort</span>!(<span class="d_string">q{ A.sizeof &lt; B.sizeof }</span>, Types) Inc;
<span class="d_keyword">alias</span> meta.<span class="d_psymbol">sort</span>!(<span class="d_string">q{ A.sizeof &gt; B.sizeof }</span>, Types) Dec;

<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>( Inc == meta.Seq!(<span class="d_keyword">bool</span>, <span class="d_keyword">short</span>, <span class="d_keyword">int</span>, <span class="d_keyword">uint</span>, <span class="d_keyword">double</span>) ));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>( Dec == meta.Seq!(<span class="d_keyword">double</span>, <span class="d_keyword">int</span>, <span class="d_keyword">uint</span>, <span class="d_keyword">short</span>, <span class="d_keyword">bool</span>) ));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="isSorted"></a><u>isSorted</u>(alias comp,seq...)</div></dt>
<dd>Determines if <span class="d_inlinecode">seq</span> is sorted according to <span class="d_inlinecode">comp</span>.  <span class="d_inlinecode">seq</span> is sorted
if and only if <span class="d_inlinecode">meta.sort!(comp, seq)</span> matches <span class="d_inlinecode">seq</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>comp</td>
<td valign=top>Binary comparison template.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to examine.</td></tr>
</table><p></p>
<b>Returns:</b><br><span class="d_inlinecode"><b>true</b></span> iff, for any valid indices <span class="d_inlinecode">i &gt; j</span>, <span class="d_inlinecode">comp!(seq[i], seq[j])</span>
 evaluates to <span class="d_inlinecode"><b>false</b></span>.

<p></p>
<b>Example:</b><br>
The second sequence in the following example is not sorted since
 <span class="d_inlinecode">ushort.sizeof &lt; int.sizeof</span> is <b>true</b>.
<pre class="d_code"><span class="d_keyword">static</span> <span class="d_keyword">assert</span>( meta.<span class="d_psymbol">isSorted</span>!(<span class="d_string">q{ A.sizeof &lt; B.sizeof }</span>, <span class="d_keyword">byte</span>, <span class="d_keyword">short</span>, <span class="d_keyword">ushort</span>));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!meta.<span class="d_psymbol">isSorted</span>!(<span class="d_string">q{ A.sizeof &lt; B.sizeof }</span>, <span class="d_keyword">byte</span>,   <span class="d_keyword">int</span>, <span class="d_keyword">ushort</span>));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="uniq"></a><u>uniq</u>(seq...)</div></dt>
<dd>Removes any consecutive group of duplicate elements in <span class="d_inlinecode">seq</span> except the
first one of each group.  Duplicates are detected with <span class="d_inlinecode">meta.isSame</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>seq</td>
<td valign=top>Target sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br><span class="d_inlinecode">seq</span> without any consecutive duplicate elements.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">uniq</span>!(1, 2, 3, 3, 4, 4, 4, 2, 2) result;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>([ result ] == [ 1, 2, 3, 4, 2 ]);
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="uniqBy"></a><u>uniqBy</u>(alias eq,seq...)</div></dt>
<dd>Generalization of <span class="d_inlinecode">meta.uniq</span> detecting duplicates with <span class="d_inlinecode">eq</span>, instead
of <span class="d_inlinecode">meta.isSame</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>eq</td>
<td valign=top>Binary predicate template that determines if passed-in arguments are
       the same (or duplicated).</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Target sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence <span class="d_inlinecode">seq</span> in which any consecutive group of duplicate elements are
 squeezed into the fist one of each group.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">uniqBy</span>!(<span class="d_string">q{ A.sizeof == B.sizeof }</span>,
                   <span class="d_keyword">int</span>, <span class="d_keyword">uint</span>, <span class="d_keyword">short</span>, <span class="d_keyword">ushort</span>, <span class="d_keyword">uint</span>) Res;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Res == meta.Seq!(<span class="d_keyword">int</span>, <span class="d_keyword">short</span>, <span class="d_keyword">uint</span>)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="removeDuplicates"></a><u>removeDuplicates</u>(seq...)</div></dt>
<dd>Completely removes all duplicate elements in <span class="d_inlinecode">seq</span> except the first one.
Duplicates are detected with <span class="d_inlinecode">meta.isSame</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>seq</td>
<td valign=top>Target sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence <span class="d_inlinecode">seq</span> without any duplicate elements.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">removeDuplicates</span>!(<span class="d_keyword">int</span>, <span class="d_keyword">bool</span>, <span class="d_keyword">bool</span>, <span class="d_keyword">int</span>, string) Res;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Res == meta.Seq!(<span class="d_keyword">int</span>, <span class="d_keyword">bool</span>, string)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="removeDuplicatesBy"></a><u>removeDuplicatesBy</u>(alias eq,seq...)</div></dt>
<dd>Generalization of <span class="d_inlinecode">meta.removeDuplicates</span> detecting duplicates with
<span class="d_inlinecode">eq</span>, instead of <span class="d_inlinecode">meta.isSame</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>eq</td>
<td valign=top>Binary predicate template that determines if passed-in arguments are
       the same (or duplicated).</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Target sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence <span class="d_inlinecode">seq</span> in which any group of duplicate elements are eliminated
 except the fist one of each group.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">alias</span> meta.<span class="d_psymbol">removeDuplicatesBy</span>!(<span class="d_string">q{ A.sizeof == B.sizeof }</span>,
                               <span class="d_keyword">int</span>, <span class="d_keyword">uint</span>, <span class="d_keyword">short</span>, <span class="d_keyword">ushort</span>, <span class="d_keyword">uint</span>) Res;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Res == meta.Seq!(<span class="d_keyword">int</span>, <span class="d_keyword">short</span>)));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="reduce"></a><u>reduce</u>(alias fun,Seed,seq...)<br>template <a name="reduce"></a><u>reduce</u>(alias fun,alias Seed,seq...)</div></dt>
<dd>Reduces the sequence <span class="d_inlinecode">seq</span> by successively applying a binary template
<span class="d_inlinecode">fun</span> over elements, with an initial state <span class="d_inlinecode">Seed</span>:
<pre class="d_code">fun!( ... fun!(fun!(Seed, seq[0]), seq[1]) ..., seq[$ - 1])
</pre>
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>fun</td>
<td valign=top>Binary template or string.</td></tr>
<tr><td valign=top>Seed</td>
<td valign=top>The initial state.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence of zero or more compile-time entities to reduce.</td></tr>
</table><p></p>
<b>Returns:</b><br>The last result of <span class="d_inlinecode">fun</span>, or <span class="d_inlinecode">Seed</span> if <span class="d_inlinecode">seq</span> is empty.

<p></p>
<b>Example:</b><br>
Computing the net accumulation of the size of types.
<pre class="d_code"><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, <span class="d_keyword">short</span>, <span class="d_keyword">bool</span>, <span class="d_keyword">dchar</span>) Types;

<span class="d_comment">// Note: 'a' gets the "current sum" and 'B' gets a type in the sequence.
</span><span class="d_keyword">enum</span> size = meta.<span class="d_psymbol">reduce</span>!(<span class="d_string">q{ a + B.sizeof }</span>, 0, Types);
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(size == 4 + 8 + 2 + 1 + 4);
</pre>

<p></p>
<b>See Also:</b><br><span class="d_inlinecode">meta.scan</span>: <a name="reduce"></a><u>reduce</u> with history.<p></p>

</dd>
<dt><div class="d_decl">template <a name="scan"></a><u>scan</u>(alias fun,Seed,seq...)<br>template <a name="scan"></a><u>scan</u>(alias fun,alias Seed,seq...)</div></dt>
<dd>Returns a sequence generated by successively applying a binary template
<span class="d_inlinecode">fun</span> over the elements of <span class="d_inlinecode">seq</span>, with an initial state <span class="d_inlinecode">Seed</span>:
<pre class="d_code"><span class="d_psymbol">scan</span>[0] = Seed;
<span class="d_psymbol">scan</span>[1] = fun!(<span class="d_psymbol">scan</span>[0], seq[0]);
<span class="d_psymbol">scan</span>[2] = fun!(<span class="d_psymbol">scan</span>[1], seq[1]);
        :
</pre>
Note that <span class="d_inlinecode"><a name="scan"></a><u>scan</u>[i]</span> is equal to <span class="d_inlinecode">meta.reduce!(fun, Seed, seq[0 .. i])</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>fun</td>
<td valign=top>Binary template or string.</td></tr>
<tr><td valign=top>Seed</td>
<td valign=top>The initial state.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence of zero or more compile-time entities to scan.</td></tr>
</table><p></p>
<b>Returns:</b><br>Sequence of the results of <span class="d_inlinecode">fun</span> preceded by <span class="d_inlinecode">Seed</span>.

<p></p>
<b>Example:</b><br>
Computing the sum of the size of types with history.
<pre class="d_code"><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">int</span>, <span class="d_keyword">double</span>, <span class="d_keyword">short</span>, <span class="d_keyword">bool</span>, <span class="d_keyword">dchar</span>) Types;

<span class="d_keyword">alias</span> meta.<span class="d_psymbol">scan</span>!(<span class="d_string">q{ a + B.sizeof }</span>, 0, Types) sums;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>([ sums ] == [ 0,
                            0+4,
                            0+4+8,
                            0+4+8+2,
                            0+4+8+2+1,
                            0+4+8+2+1+4 ]);
</pre>
 Note that <span class="d_inlinecode">sums[5]</span>, or <span class="d_inlinecode">sums[Types.length]</span>, equals the result
 of the corresponding example of <span class="d_inlinecode">meta.reduce</span>.<p></p>

</dd>
<dt><div class="d_decl">template <a name="most"></a><u>most</u>(alias comp,seq...) if (seq.length &gt; 0)<br>template <a name="most"></a><u>most</u>(string comp,seq...) if (seq.length &gt; 0)</div></dt>
<dd>Looks for the first "top" element of a sequence in terms of the specified
comparison template <span class="d_inlinecode">comp</span>.  This template is effectively the same
as <span class="d_inlinecode">meta.sort!(comp, seq)[0]</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>comp</td>
<td valign=top>Binary template or expression string that compares items in
        the sequence for an ordering.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>One or more compile-time entities.</td></tr>
</table><p></p>
<b>Example:</b><br>
To get the largest element in the sequence, specify a greater-than operator
 as the <span class="d_inlinecode">comp</span> argument.
<pre class="d_code"><span class="d_keyword">alias</span> meta.Seq!(<span class="d_keyword">int</span>, <span class="d_keyword">bool</span>, <span class="d_keyword">double</span>, <span class="d_keyword">short</span>) Types;

<span class="d_comment">// Take the largest type in the sequence: double.
</span><span class="d_keyword">alias</span> meta.<span class="d_psymbol">most</span>!(<span class="d_string">q{ A.sizeof &gt; B.sizeof }</span>, Types) Largest;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(Largest == <span class="d_keyword">double</span>));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="find"></a><u>find</u>(E,seq...)<br>template <a name="find"></a><u>find</u>(alias E,seq...)</div></dt>
<dd>Looks for the first occurrence of <span class="d_inlinecode">E</span> in <span class="d_inlinecode">seq</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>E</td>
<td valign=top>Compile-time entity to look for.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to find.</td></tr>
</table><p></p>
<b>Returns:</b><br>Subsequence of <span class="d_inlinecode">seq</span> after <span class="d_inlinecode">E</span> (inclusive).  The empty sequence
 is returned if <span class="d_inlinecode">E</span> is not found.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="findIf"></a><u>findIf</u>(alias pred,seq...)<br>template <a name="findIf"></a><u>findIf</u>(string pred,seq...)</div></dt>
<dd>Same as <span class="d_inlinecode">find</span>, but looks for an item that satisfies a unary predicate.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Unary predicate template or expression string.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Sequence to find.</td></tr>
</table><p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="until"></a><u>until</u>(E,seq...)<br>template <a name="until"></a><u>until</u>(alias E,seq...)</div></dt>
<dd>Takes a subsequence of <span class="d_inlinecode">seq</span> <a name="until"></a><u>until</u> encountering <span class="d_inlinecode">E</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>E</td>
<td valign=top>Compile-time entity to look for.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Target sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br>Subsequence of <span class="d_inlinecode">seq</span> before <span class="d_inlinecode">E</span> (exclusive).  The given <span class="d_inlinecode">seq</span> is
 returned as is if <span class="d_inlinecode">E</span> is not found.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="untilIf"></a><u>untilIf</u>(alias pred,seq...)</div></dt>
<dd>Same as <span class="d_inlinecode">until</span>, but stops at an item that satisfies a unary predicate.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Unary predicate template or expression string.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Target sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="index"></a><u>index</u>(E,seq...)<br>template <a name="index"></a><u>index</u>(alias E,seq...)</div></dt>
<dd>Same as evaluating <span class="d_inlinecode">until!(E, seq).length</span> except that <span class="d_inlinecode">-1</span> is
returned if <span class="d_inlinecode">E</span> is not found.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>E</td>
<td valign=top>.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>.</td></tr>
</table><p></p>
<b>Returns:</b><br>.  The type of the result is <span class="d_inlinecode">sizediff_t</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="indexIf"></a><u>indexIf</u>(alias pred,seq...)</div></dt>
<dd>Same as evaluating <span class="d_inlinecode">untilIf!(pred, seq).length</span> except that <span class="d_inlinecode">-1</span> is
returned if no element satisfies the predicate.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>.</td></tr>
</table><p></p>
<b>Returns:</b><br>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="count"></a><u>count</u>(E,seq...)<br>template <a name="count"></a><u>count</u>(alias E,seq...)</div></dt>
<dd>Returns the number of occurrences of <span class="d_inlinecode">E</span> in <span class="d_inlinecode">seq</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>E</td>
<td valign=top>Compile-time entity to look for.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Target sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br>.  The type of the result is <span class="d_inlinecode">size_t</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="countIf"></a><u>countIf</u>(alias pred,seq...)<br>template <a name="countIf"></a><u>countIf</u>(string pred,seq...)</div></dt>
<dd>Same as <span class="d_inlinecode">meta.count</span>, but returns the number of elements that satisfy
the predicate <span class="d_inlinecode">pred</span>.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Unary predicate tempalte or expression string.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Target sequence.</td></tr>
</table><p></p>
<b>Returns:</b><br>.

<p></p>
<b>Example:</b><br>
<pre class="d_code">.
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="all"></a><u>all</u>(alias pred,seq...)<br>template <a name="any"></a><u>any</u>(alias pred,seq...)<br>template <a name="none"></a><u>none</u>(alias pred,seq...)</div></dt>
<dd>Determines if, respectively, all/any/none of the elements in a
sequence <span class="d_inlinecode">seq</span> satisfies the predicate <span class="d_inlinecode">pred</span>.  Specifically:
<pre class="d_code"> <span class="d_psymbol">all</span> =  pred!(seq[0]) &amp;&amp;  pred!(seq[1]) &amp;&amp; ... ;
 any =  pred!(seq[0]) ||  pred!(seq[1]) || ... ;
none = !pred!(seq[0]) &amp;&amp; !pred!(seq[1]) &amp;&amp; ... ;
</pre>
<p></p>
These templates evaluate conditions lazily just like usual boolean
expressions, so unnecessary instantiations will never kick in.  For
example, <span class="d_inlinecode">meta.<a name="all"></a><u>all</u></span> immediately returns <span class="d_inlinecode"><b>false</b></span> at first failing
element (if any) and doesn't instantiate <span class="d_inlinecode">pred</span> with remaining
elements.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Unary predicate template or expression string.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Zero or more compile-time entities to examine.</td></tr>
</table><p></p>
<b>Returns:</b><br><span class="d_inlinecode"><b>true</b></span> if all/any/none of the elements of the sequence satisfies
 the predicate.  For the empty sequence, <span class="d_inlinecode">meta.<a name="all"></a><u>all</u></span> and <span class="d_inlinecode">meta.none</span>
 returns <span class="d_inlinecode"><b>true</b></span>; and <span class="d_inlinecode">meta.any</span> returns <span class="d_inlinecode"><b>false</b></span>.

<p></p>
<b>Example:</b><br>
These templates would be useful in template constraints:
<pre class="d_code"><span class="d_keyword">import</span> std.meta, std.range, std.typecons;

<span class="d_comment">// This function requires all arguments should be input ranges.
</span><span class="d_keyword">auto</span> dropFront(Ranges...)(<span class="d_keyword">ref</span> Ranges ranges)
    <span class="d_keyword">if</span> (meta.<span class="d_psymbol">all</span>!(isInputRange, Ranges))
{
    Tuple!(meta.map!(ElementType, Ranges)) result;

    <span class="d_keyword">foreach</span> (i, R; Ranges)
    {
        result[i] = ranges[i].front;
        ranges[i].popFront();
    }
    <span class="d_keyword">return</span> result;
}
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="only"></a><u>only</u>(alias pred,seq...)</div></dt>
<dd>Determines if only one of the elements of <span class="d_inlinecode">seq</span> satisfies the predicate
<span class="d_inlinecode">pred</span>.  The predicate is tested for all the elements.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>pred</td>
<td valign=top>Unary predicate template or expression string.</td></tr>
<tr><td valign=top>seq</td>
<td valign=top>Zero or more compile-time entities to examine.</td></tr>
</table><p></p>
<b>Returns:</b><br><span class="d_inlinecode"><b>true</b></span> if <span class="d_inlinecode">seq</span> is not empty and only one of the elements satisfies
 the predicate.  Otherwise, <span class="d_inlinecode"><b>false</b></span> is returned.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Allow only one class in a base class list.
</span><span class="d_keyword">template</span> isValidBase(Bases...)
{
    <span class="d_keyword">enum</span> isValidBase = meta.<span class="d_psymbol">only</span>!(<span class="d_string">q{ is(A == class) }</span>, Bases);
}

<span class="d_keyword">class</span> B {}
<span class="d_keyword">class</span> C {}
<span class="d_keyword">interface</span> I {}
<span class="d_keyword">interface</span> J {}
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>( isValidBase!(B, I, J));
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!isValidBase!(B, I, C));
</pre>
<p></p>

</dd>
<dt><div class="d_decl">template <a name="setIntersection"></a><u>setIntersection</u>(alias A,alias B)</div></dt>
<dd>Set intersection.<p></p>

</dd>
<dt><div class="d_decl">template <a name="setUnion"></a><u>setUnion</u>(alias A,alias B)</div></dt>
<dd>Set union.<p></p>

</dd>
</dl>

</div>


<div id="copyright">
Copyright Shin Fujishiro 2010.
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
